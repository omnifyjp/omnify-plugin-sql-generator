{"version":3,"sources":["/Users/f.satoshi/Herd/omnify-ts/packages/omnify-plugin-sql-generator/dist/chunk-SGXQQITC.cjs","../src/dialects/formatter.ts","../src/dialects/types.ts","../src/migration/schema-builder.ts","../src/migration/generator.ts"],"names":[],"mappings":"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","file":"/Users/f.satoshi/Herd/omnify-ts/packages/omnify-plugin-sql-generator/dist/chunk-SGXQQITC.cjs","sourcesContent":[null,"/**\n * @famgia/omnify-sql - SQL Formatter\n *\n * Formats SQL statements for each dialect.\n */\n\nimport type { SqlDialect, SqlColumn, SqlForeignKey, SqlIndex, SqlTable } from '../types.js';\n\n/**\n * Quotes an identifier based on dialect.\n */\nexport function quoteIdentifier(name: string, dialect: SqlDialect): string {\n  switch (dialect) {\n    case 'mysql':\n      return `\\`${name}\\``;\n    case 'postgresql':\n      return `\"${name}\"`;\n    case 'sqlite':\n      return `\"${name}\"`;\n  }\n}\n\n/**\n * Quotes a string value.\n */\nexport function quoteString(value: string): string {\n  return `'${value.replace(/'/g, \"''\")}'`;\n}\n\n/**\n * Formats a column definition.\n */\nexport function formatColumn(column: SqlColumn, dialect: SqlDialect): string {\n  const parts: string[] = [quoteIdentifier(column.name, dialect), column.type];\n\n  // Unsigned (MySQL only, and only if not already in type)\n  if (dialect === 'mysql' && column.unsigned && !column.type.includes('UNSIGNED')) {\n    parts.push('UNSIGNED');\n  }\n\n  // NOT NULL / NULL\n  if (!column.nullable && !column.primaryKey) {\n    parts.push('NOT NULL');\n  } else if (column.nullable) {\n    parts.push('NULL');\n  }\n\n  // Auto increment\n  if (column.autoIncrement) {\n    switch (dialect) {\n      case 'mysql':\n        parts.push('AUTO_INCREMENT');\n        break;\n      case 'sqlite':\n        // SQLite uses AUTOINCREMENT only with INTEGER PRIMARY KEY\n        break;\n      case 'postgresql':\n        // PostgreSQL uses SERIAL/BIGSERIAL types instead\n        break;\n    }\n  }\n\n  // Primary key (inline for single column)\n  if (column.primaryKey) {\n    parts.push('PRIMARY KEY');\n    if (dialect === 'sqlite' && column.autoIncrement) {\n      parts.push('AUTOINCREMENT');\n    }\n  }\n\n  // Unique\n  if (column.unique && !column.primaryKey) {\n    parts.push('UNIQUE');\n  }\n\n  // Default value\n  if (column.defaultValue !== undefined) {\n    parts.push(`DEFAULT ${column.defaultValue}`);\n  }\n\n  // Comment (MySQL only inline)\n  if (column.comment && dialect === 'mysql') {\n    parts.push(`COMMENT ${quoteString(column.comment)}`);\n  }\n\n  return parts.join(' ');\n}\n\n/**\n * Formats a foreign key constraint.\n */\nexport function formatForeignKey(fk: SqlForeignKey, dialect: SqlDialect): string {\n  const localCols = fk.columns.map(c => quoteIdentifier(c, dialect)).join(', ');\n  const refCols = fk.referencesColumns.map(c => quoteIdentifier(c, dialect)).join(', ');\n  const refTable = quoteIdentifier(fk.referencesTable, dialect);\n\n  let sql = `CONSTRAINT ${quoteIdentifier(fk.name, dialect)} `;\n  sql += `FOREIGN KEY (${localCols}) `;\n  sql += `REFERENCES ${refTable} (${refCols})`;\n\n  if (fk.onDelete && fk.onDelete !== 'NO ACTION') {\n    sql += ` ON DELETE ${fk.onDelete}`;\n  }\n\n  if (fk.onUpdate && fk.onUpdate !== 'NO ACTION') {\n    sql += ` ON UPDATE ${fk.onUpdate}`;\n  }\n\n  return sql;\n}\n\n/**\n * Formats an index definition.\n */\nexport function formatIndex(index: SqlIndex, tableName: string, dialect: SqlDialect): string {\n  const cols = index.columns.map(c => quoteIdentifier(c, dialect)).join(', ');\n  const table = quoteIdentifier(tableName, dialect);\n  const name = quoteIdentifier(index.name, dialect);\n\n  // Handle special index types\n  if (index.type === 'fulltext') {\n    switch (dialect) {\n      case 'mysql':\n        return `CREATE FULLTEXT INDEX ${name} ON ${table} (${cols});`;\n      case 'postgresql':\n        // PostgreSQL uses GIN index with to_tsvector\n        const tsvectorCols = index.columns.map(c => `to_tsvector('english', ${quoteIdentifier(c, dialect)})`).join(' || ');\n        return `CREATE INDEX ${name} ON ${table} USING GIN (${tsvectorCols});`;\n      case 'sqlite':\n        // SQLite FTS requires virtual table, just create regular index\n        return `CREATE INDEX ${name} ON ${table} (${cols});`;\n    }\n  }\n\n  if (index.type === 'spatial') {\n    switch (dialect) {\n      case 'mysql':\n        return `CREATE SPATIAL INDEX ${name} ON ${table} (${cols});`;\n      case 'postgresql':\n        return `CREATE INDEX ${name} ON ${table} USING GIST (${cols});`;\n      case 'sqlite':\n        return `CREATE INDEX ${name} ON ${table} (${cols});`;\n    }\n  }\n\n  if (index.type === 'gin' && dialect === 'postgresql') {\n    return `CREATE INDEX ${name} ON ${table} USING GIN (${cols});`;\n  }\n\n  if (index.type === 'gist' && dialect === 'postgresql') {\n    return `CREATE INDEX ${name} ON ${table} USING GIST (${cols});`;\n  }\n\n  if (index.type === 'hash') {\n    switch (dialect) {\n      case 'mysql':\n        return `CREATE INDEX ${name} ON ${table} (${cols}) USING HASH;`;\n      case 'postgresql':\n        return `CREATE INDEX ${name} ON ${table} USING HASH (${cols});`;\n      case 'sqlite':\n        return `CREATE INDEX ${name} ON ${table} (${cols});`;\n    }\n  }\n\n  // Default: btree or regular index\n  const indexType = index.unique ? 'UNIQUE INDEX' : 'INDEX';\n  return `CREATE ${indexType} ${name} ON ${table} (${cols});`;\n}\n\n/**\n * Formats a complete CREATE TABLE statement.\n */\nexport function formatCreateTable(\n  table: SqlTable,\n  dialect: SqlDialect,\n  options?: { ifNotExists?: boolean }\n): string {\n  const tableName = quoteIdentifier(table.name, dialect);\n  const ifNotExists = options?.ifNotExists ? 'IF NOT EXISTS ' : '';\n\n  const lines: string[] = [];\n\n  // Columns\n  for (const column of table.columns) {\n    lines.push(`  ${formatColumn(column, dialect)}`);\n  }\n\n  // Foreign keys (inline in CREATE TABLE)\n  for (const fk of table.foreignKeys) {\n    lines.push(`  ${formatForeignKey(fk, dialect)}`);\n  }\n\n  let sql = `CREATE TABLE ${ifNotExists}${tableName} (\\n`;\n  sql += lines.join(',\\n');\n  sql += '\\n)';\n\n  // MySQL engine and charset\n  if (dialect === 'mysql') {\n    sql += ' ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci';\n  }\n\n  sql += ';';\n\n  // Add table comment for PostgreSQL (separate statement)\n  if (table.comment && dialect === 'postgresql') {\n    sql += `\\n\\nCOMMENT ON TABLE ${tableName} IS ${quoteString(table.comment)};`;\n  }\n\n  return sql;\n}\n\n/**\n * Formats a DROP TABLE statement.\n */\nexport function formatDropTable(\n  tableName: string,\n  dialect: SqlDialect,\n  options?: { ifExists?: boolean; cascade?: boolean }\n): string {\n  const table = quoteIdentifier(tableName, dialect);\n  const ifExists = options?.ifExists ? 'IF EXISTS ' : '';\n  const cascade = options?.cascade && dialect === 'postgresql' ? ' CASCADE' : '';\n\n  return `DROP TABLE ${ifExists}${table}${cascade};`;\n}\n\n/**\n * Formats indexes as separate statements (after CREATE TABLE).\n */\nexport function formatIndexes(table: SqlTable, dialect: SqlDialect): string[] {\n  return table.indexes.map(index => formatIndex(index, table.name, dialect));\n}\n\n/**\n * Formats column comments for PostgreSQL (separate statements).\n */\nexport function formatColumnComments(table: SqlTable, dialect: SqlDialect): string[] {\n  if (dialect !== 'postgresql') {\n    return [];\n  }\n\n  const statements: string[] = [];\n  const tableName = quoteIdentifier(table.name, dialect);\n\n  for (const column of table.columns) {\n    if (column.comment) {\n      const colName = quoteIdentifier(column.name, dialect);\n      statements.push(\n        `COMMENT ON COLUMN ${tableName}.${colName} IS ${quoteString(column.comment)};`\n      );\n    }\n  }\n\n  return statements;\n}\n","/**\n * @famgia/omnify-sql - Dialect Type Mappings\n *\n * Maps Omnify types to SQL types for each dialect.\n */\n\nimport type { SqlDialect } from '../types.js';\n\n/**\n * Type mapping for each dialect.\n */\nexport interface TypeMapping {\n  /** SQL type string */\n  readonly type: string;\n  /** Whether type supports length parameter */\n  readonly hasLength?: boolean;\n  /** Default length if applicable */\n  readonly defaultLength?: number;\n  /** Whether type supports precision/scale */\n  readonly hasPrecision?: boolean;\n}\n\n/**\n * MySQL type mappings.\n */\nconst MYSQL_TYPES: Record<string, TypeMapping> = {\n  String: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  Int: { type: 'INT' },\n  BigInt: { type: 'BIGINT' },\n  Float: { type: 'DOUBLE' },\n  Decimal: { type: 'DECIMAL', hasPrecision: true },\n  Boolean: { type: 'TINYINT(1)' },\n  Text: { type: 'TEXT' },\n  LongText: { type: 'LONGTEXT' },\n  Date: { type: 'DATE' },\n  Time: { type: 'TIME' },\n  Timestamp: { type: 'TIMESTAMP' },\n  Json: { type: 'JSON' },\n  Email: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  Password: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  File: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  MultiFile: { type: 'JSON' },\n  Uuid: { type: 'CHAR(36)' },\n  Select: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  Lookup: { type: 'BIGINT UNSIGNED' },\n  // Spatial types\n  Point: { type: 'POINT' },\n  Coordinates: { type: 'DECIMAL(10, 8)' }, // For latitude column (longitude uses DECIMAL(11, 8))\n};\n\n/**\n * PostgreSQL type mappings.\n */\nconst POSTGRESQL_TYPES: Record<string, TypeMapping> = {\n  String: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  Int: { type: 'INTEGER' },\n  BigInt: { type: 'BIGINT' },\n  Float: { type: 'DOUBLE PRECISION' },\n  Decimal: { type: 'DECIMAL', hasPrecision: true },\n  Boolean: { type: 'BOOLEAN' },\n  Text: { type: 'TEXT' },\n  LongText: { type: 'TEXT' },\n  Date: { type: 'DATE' },\n  Time: { type: 'TIME' },\n  Timestamp: { type: 'TIMESTAMP' },\n  Json: { type: 'JSONB' },\n  Email: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  Password: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  File: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  MultiFile: { type: 'JSONB' },\n  Uuid: { type: 'UUID' },\n  Select: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  Lookup: { type: 'BIGINT' },\n  // Spatial types (requires PostGIS extension)\n  Point: { type: 'geometry(Point, 4326)' },\n  Coordinates: { type: 'DECIMAL(10, 8)' }, // For latitude column\n};\n\n/**\n * SQLite type mappings.\n */\nconst SQLITE_TYPES: Record<string, TypeMapping> = {\n  String: { type: 'TEXT' },\n  Int: { type: 'INTEGER' },\n  BigInt: { type: 'INTEGER' },\n  Float: { type: 'REAL' },\n  Decimal: { type: 'REAL' },\n  Boolean: { type: 'INTEGER' },\n  Text: { type: 'TEXT' },\n  LongText: { type: 'TEXT' },\n  Date: { type: 'TEXT' },\n  Time: { type: 'TEXT' },\n  Timestamp: { type: 'TEXT' },\n  Json: { type: 'TEXT' },\n  Email: { type: 'TEXT' },\n  Password: { type: 'TEXT' },\n  File: { type: 'TEXT' },\n  MultiFile: { type: 'TEXT' },\n  Uuid: { type: 'TEXT' },\n  Select: { type: 'TEXT' },\n  Lookup: { type: 'INTEGER' },\n  // Spatial types (no native support, use TEXT for JSON or REAL for lat/lon)\n  Point: { type: 'TEXT' }, // JSON representation: {\"lat\": 0, \"lon\": 0}\n  Coordinates: { type: 'REAL' }, // For latitude/longitude columns\n};\n\n/**\n * All dialect mappings.\n */\nconst DIALECT_TYPES: Record<SqlDialect, Record<string, TypeMapping>> = {\n  mysql: MYSQL_TYPES,\n  postgresql: POSTGRESQL_TYPES,\n  sqlite: SQLITE_TYPES,\n};\n\n/**\n * Gets the SQL type for an Omnify type in a specific dialect.\n */\nexport function getSqlType(\n  omnifyType: string,\n  dialect: SqlDialect,\n  options?: { length?: number | undefined; precision?: number | undefined; scale?: number | undefined }\n): string {\n  const mapping = DIALECT_TYPES[dialect][omnifyType];\n\n  if (!mapping) {\n    // Default fallback\n    return dialect === 'sqlite' ? 'TEXT' : 'VARCHAR(255)';\n  }\n\n  let type = mapping.type;\n\n  // Add length if applicable\n  if (mapping.hasLength) {\n    const length = options?.length ?? mapping.defaultLength ?? 255;\n    type = `${type}(${length})`;\n  }\n\n  // Add precision/scale if applicable\n  if (mapping.hasPrecision && options?.precision) {\n    const scale = options.scale ?? 2;\n    type = `${type}(${options.precision}, ${scale})`;\n  }\n\n  return type;\n}\n\n/**\n * Gets the primary key type for a specific dialect.\n */\nexport function getPrimaryKeyType(\n  idType: 'Int' | 'BigInt' | 'Uuid' | 'String',\n  dialect: SqlDialect\n): { type: string; autoIncrement: boolean } {\n  switch (dialect) {\n    case 'mysql':\n      switch (idType) {\n        case 'Int':\n          return { type: 'INT UNSIGNED', autoIncrement: true };\n        case 'BigInt':\n          return { type: 'BIGINT UNSIGNED', autoIncrement: true };\n        case 'Uuid':\n          return { type: 'CHAR(36)', autoIncrement: false };\n        case 'String':\n          return { type: 'VARCHAR(255)', autoIncrement: false };\n      }\n      break;\n\n    case 'postgresql':\n      switch (idType) {\n        case 'Int':\n          return { type: 'SERIAL', autoIncrement: false }; // SERIAL handles auto-increment\n        case 'BigInt':\n          return { type: 'BIGSERIAL', autoIncrement: false };\n        case 'Uuid':\n          return { type: 'UUID', autoIncrement: false };\n        case 'String':\n          return { type: 'VARCHAR(255)', autoIncrement: false };\n      }\n      break;\n\n    case 'sqlite':\n      switch (idType) {\n        case 'Int':\n        case 'BigInt':\n          return { type: 'INTEGER', autoIncrement: true };\n        case 'Uuid':\n        case 'String':\n          return { type: 'TEXT', autoIncrement: false };\n      }\n      break;\n  }\n\n  return { type: 'BIGINT', autoIncrement: true };\n}\n\n/**\n * Gets the foreign key column type.\n */\nexport function getForeignKeyType(\n  referencedIdType: 'Int' | 'BigInt' | 'Uuid' | 'String',\n  dialect: SqlDialect\n): string {\n  switch (dialect) {\n    case 'mysql':\n      switch (referencedIdType) {\n        case 'Int':\n          return 'INT UNSIGNED';\n        case 'BigInt':\n          return 'BIGINT UNSIGNED';\n        case 'Uuid':\n          return 'CHAR(36)';\n        case 'String':\n          return 'VARCHAR(255)';\n      }\n      break;\n\n    case 'postgresql':\n      switch (referencedIdType) {\n        case 'Int':\n          return 'INTEGER';\n        case 'BigInt':\n          return 'BIGINT';\n        case 'Uuid':\n          return 'UUID';\n        case 'String':\n          return 'VARCHAR(255)';\n      }\n      break;\n\n    case 'sqlite':\n      switch (referencedIdType) {\n        case 'Int':\n        case 'BigInt':\n          return 'INTEGER';\n        case 'Uuid':\n        case 'String':\n          return 'TEXT';\n      }\n      break;\n  }\n\n  return 'BIGINT';\n}\n\n/**\n * Gets ENUM type for a dialect.\n * Note: PostgreSQL requires CREATE TYPE, MySQL uses ENUM inline, SQLite uses CHECK.\n */\nexport function getEnumType(\n  values: readonly string[],\n  dialect: SqlDialect,\n  enumName?: string\n): { type: string; preStatement?: string } {\n  switch (dialect) {\n    case 'mysql':\n      const enumValues = values.map(v => `'${v}'`).join(', ');\n      return { type: `ENUM(${enumValues})` };\n\n    case 'postgresql':\n      // PostgreSQL needs CREATE TYPE first\n      const typeName = enumName ?? 'enum_type';\n      const pgValues = values.map(v => `'${v}'`).join(', ');\n      return {\n        type: typeName,\n        preStatement: `CREATE TYPE ${typeName} AS ENUM (${pgValues});`,\n      };\n\n    case 'sqlite':\n      // SQLite uses CHECK constraint, return TEXT and add constraint later\n      return { type: 'TEXT' };\n  }\n}\n","/**\n * @famgia/omnify-sql - Schema Builder\n *\n * Converts Omnify schemas to SQL table definitions.\n */\n\nimport type { LoadedSchema, PropertyDefinition, SchemaCollection } from '@famgia/omnify-types';\nimport { resolveLocalizedString } from '@famgia/omnify-types';\nimport type {\n  SqlDialect,\n  SqlTable,\n  SqlColumn,\n  SqlForeignKey,\n  SqlIndex,\n  ResolvedSqlOptions,\n} from '../types.js';\nimport { getSqlType, getPrimaryKeyType, getForeignKeyType, getEnumType } from '../dialects/types.js';\n\n/**\n * Converts camelCase to snake_case.\n */\nexport function toSnakeCase(str: string): string {\n  return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`).replace(/^_/, '');\n}\n\n/**\n * Converts schema name to table name (snake_case + plural).\n */\nexport function toTableName(schemaName: string): string {\n  const snake = toSnakeCase(schemaName);\n\n  // Simple pluralization rules\n  if (snake.endsWith('y') && !['ay', 'ey', 'oy', 'uy'].some(v => snake.endsWith(v))) {\n    return snake.slice(0, -1) + 'ies';\n  }\n  if (snake.endsWith('s') || snake.endsWith('x') || snake.endsWith('ch') || snake.endsWith('sh')) {\n    return snake + 'es';\n  }\n  return snake + 's';\n}\n\n/**\n * Converts property name to column name (snake_case).\n */\nexport function toColumnName(propertyName: string): string {\n  return toSnakeCase(propertyName);\n}\n\n/**\n * Generates primary key column.\n */\nexport function generatePrimaryKey(\n  idType: 'Int' | 'BigInt' | 'Uuid' | 'String',\n  dialect: SqlDialect\n): SqlColumn {\n  const pkInfo = getPrimaryKeyType(idType, dialect);\n\n  return {\n    name: 'id',\n    type: pkInfo.type,\n    nullable: false,\n    primaryKey: true,\n    autoIncrement: pkInfo.autoIncrement,\n    unique: false,\n    unsigned: false,\n  };\n}\n\n/**\n * Generates timestamp columns (created_at, updated_at).\n */\nexport function generateTimestampColumns(dialect: SqlDialect): SqlColumn[] {\n  const timestampType = dialect === 'sqlite' ? 'TEXT' : 'TIMESTAMP';\n\n  return [\n    {\n      name: 'created_at',\n      type: timestampType,\n      nullable: true,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: false,\n    },\n    {\n      name: 'updated_at',\n      type: timestampType,\n      nullable: true,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: false,\n    },\n  ];\n}\n\n/**\n * Generates soft delete column.\n */\nexport function generateSoftDeleteColumn(dialect: SqlDialect): SqlColumn {\n  const timestampType = dialect === 'sqlite' ? 'TEXT' : 'TIMESTAMP';\n\n  return {\n    name: 'deleted_at',\n    type: timestampType,\n    nullable: true,\n    primaryKey: false,\n    autoIncrement: false,\n    unique: false,\n    unsigned: false,\n  };\n}\n\n/**\n * Generates coordinate columns for Coordinates type.\n * Returns two columns: {name}_latitude and {name}_longitude\n */\nexport function generateCoordinatesColumns(\n  name: string,\n  property: PropertyDefinition,\n  dialect: SqlDialect\n): SqlColumn[] {\n  const baseName = toColumnName(name);\n  const nullable = (property as { nullable?: boolean }).nullable ?? false;\n\n  // Latitude: -90 to +90 (needs 10,8 precision)\n  // Longitude: -180 to +180 (needs 11,8 precision)\n  const latType = dialect === 'sqlite' ? 'REAL' : 'DECIMAL(10, 8)';\n  const lonType = dialect === 'sqlite' ? 'REAL' : 'DECIMAL(11, 8)';\n\n  return [\n    {\n      name: `${baseName}_latitude`,\n      type: latType,\n      nullable,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: false,\n      comment: `Latitude for ${name}`,\n    },\n    {\n      name: `${baseName}_longitude`,\n      type: lonType,\n      nullable,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: false,\n      comment: `Longitude for ${name}`,\n    },\n  ];\n}\n\n/**\n * Converts a property to a SQL column.\n * Returns null for association types and Coordinates (handled separately).\n */\nexport function propertyToColumn(\n  name: string,\n  property: PropertyDefinition,\n  dialect: SqlDialect,\n  _allSchemas: SchemaCollection\n): SqlColumn | null {\n  // Skip associations - they're handled separately\n  if (property.type === 'Association') {\n    return null;\n  }\n\n  // Skip Coordinates - handled separately (generates 2 columns)\n  if (property.type === 'Coordinates') {\n    return null;\n  }\n\n  const columnName = toColumnName(name);\n  const baseProp = property as {\n    nullable?: boolean;\n    unique?: boolean;\n    default?: unknown;\n    displayName?: string;\n    length?: number;\n    precision?: number;\n    scale?: number;\n    enum?: string | readonly string[];\n    options?: readonly string[];\n  };\n\n  // Handle Enum type\n  if (property.type === 'Enum') {\n    if (Array.isArray(baseProp.enum)) {\n      const enumInfo = getEnumType(baseProp.enum, dialect, `${columnName}_enum`);\n      return {\n        name: columnName,\n        type: enumInfo.type,\n        nullable: baseProp.nullable ?? false,\n        primaryKey: false,\n        autoIncrement: false,\n        unique: baseProp.unique ?? false,\n        unsigned: false,\n        defaultValue: baseProp.default !== undefined ? `'${baseProp.default}'` : undefined,\n        comment: baseProp.displayName,\n      };\n    }\n  }\n\n  // Handle Select type\n  if (property.type === 'Select' && baseProp.options) {\n    const enumInfo = getEnumType(baseProp.options, dialect, `${columnName}_enum`);\n    return {\n      name: columnName,\n      type: enumInfo.type,\n      nullable: baseProp.nullable ?? false,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: baseProp.unique ?? false,\n      unsigned: false,\n      defaultValue: baseProp.default !== undefined ? `'${baseProp.default}'` : undefined,\n      comment: baseProp.displayName,\n    };\n  }\n\n  // Standard type mapping\n  const sqlType = getSqlType(property.type, dialect, {\n    length: baseProp.length,\n    precision: baseProp.precision,\n    scale: baseProp.scale,\n  });\n\n  // Format default value\n  let defaultValue: string | undefined;\n  if (baseProp.default !== undefined) {\n    if (typeof baseProp.default === 'string') {\n      defaultValue = `'${baseProp.default}'`;\n    } else if (typeof baseProp.default === 'boolean') {\n      defaultValue = dialect === 'postgresql' ? (baseProp.default ? 'TRUE' : 'FALSE') : (baseProp.default ? '1' : '0');\n    } else {\n      defaultValue = String(baseProp.default);\n    }\n  }\n\n  return {\n    name: columnName,\n    type: sqlType,\n    nullable: baseProp.nullable ?? false,\n    primaryKey: false,\n    autoIncrement: false,\n    unique: baseProp.unique ?? false,\n    unsigned: false,\n    defaultValue,\n    comment: baseProp.displayName,\n  };\n}\n\n/**\n * Generates foreign key column and constraint for an association.\n */\nexport function generateForeignKey(\n  name: string,\n  property: PropertyDefinition,\n  schema: LoadedSchema,\n  dialect: SqlDialect,\n  allSchemas: SchemaCollection\n): { column: SqlColumn; foreignKey: SqlForeignKey } | null {\n  if (property.type !== 'Association') {\n    return null;\n  }\n\n  const assocProp = property as {\n    relation?: string;\n    target?: string;\n    targets?: readonly string[];\n    onDelete?: string;\n    onUpdate?: string;\n  };\n\n  // Only handle owning side relations\n  if (!['ManyToOne', 'OneToOne'].includes(assocProp.relation ?? '')) {\n    return null;\n  }\n\n  const targetName = assocProp.target;\n  if (!targetName) {\n    return null;\n  }\n\n  const targetSchema = allSchemas[targetName];\n  const targetIdType = (targetSchema?.options?.idType ?? 'BigInt') as 'Int' | 'BigInt' | 'Uuid' | 'String';\n\n  const columnName = `${toColumnName(name)}_id`;\n  const fkType = getForeignKeyType(targetIdType, dialect);\n  const constraintName = `fk_${toTableName(schema.name)}_${columnName}`;\n\n  const column: SqlColumn = {\n    name: columnName,\n    type: fkType,\n    nullable: (property as { nullable?: boolean }).nullable ?? false,\n    primaryKey: false,\n    autoIncrement: false,\n    unique: false,\n    unsigned: dialect === 'mysql' && ['Int', 'BigInt'].includes(targetIdType),\n  };\n\n  const foreignKey: SqlForeignKey = {\n    name: constraintName,\n    columns: [columnName],\n    referencesTable: toTableName(targetName),\n    referencesColumns: ['id'],\n    onDelete: assocProp.onDelete ?? 'CASCADE',\n    onUpdate: assocProp.onUpdate ?? 'CASCADE',\n  };\n\n  return { column, foreignKey };\n}\n\n/**\n * Generates polymorphic columns for MorphTo relation.\n */\nexport function generatePolymorphicColumns(\n  name: string,\n  property: PropertyDefinition,\n  dialect: SqlDialect,\n  allSchemas: SchemaCollection\n): { columns: SqlColumn[]; index: SqlIndex } | null {\n  if (property.type !== 'Association') {\n    return null;\n  }\n\n  const assocProp = property as {\n    relation?: string;\n    targets?: readonly string[];\n  };\n\n  if (assocProp.relation !== 'MorphTo' || !assocProp.targets?.length) {\n    return null;\n  }\n\n  const baseName = toColumnName(name);\n\n  // Determine ID type (use UUID if any target uses UUID)\n  let useUuid = false;\n  for (const targetName of assocProp.targets) {\n    const targetSchema = allSchemas[targetName];\n    if (targetSchema?.options?.idType === 'Uuid') {\n      useUuid = true;\n      break;\n    }\n  }\n\n  // Type column (ENUM)\n  const enumInfo = getEnumType(assocProp.targets, dialect, `${baseName}_type_enum`);\n  const typeColumn: SqlColumn = {\n    name: `${baseName}_type`,\n    type: enumInfo.type,\n    nullable: true,\n    primaryKey: false,\n    autoIncrement: false,\n    unique: false,\n    unsigned: false,\n  };\n\n  // ID column\n  const idType = useUuid\n    ? (dialect === 'mysql' ? 'CHAR(36)' : dialect === 'postgresql' ? 'UUID' : 'TEXT')\n    : (dialect === 'mysql' ? 'BIGINT UNSIGNED' : dialect === 'postgresql' ? 'BIGINT' : 'INTEGER');\n\n  const idColumn: SqlColumn = {\n    name: `${baseName}_id`,\n    type: idType,\n    nullable: true,\n    primaryKey: false,\n    autoIncrement: false,\n    unique: false,\n    unsigned: dialect === 'mysql' && !useUuid,\n  };\n\n  // Composite index\n  const index: SqlIndex = {\n    name: `idx_${baseName}_type_id`,\n    columns: [`${baseName}_type`, `${baseName}_id`],\n    unique: false,\n  };\n\n  return {\n    columns: [typeColumn, idColumn],\n    index,\n  };\n}\n\n/**\n * Converts a schema to a SQL table definition.\n */\nexport function schemaToTable(\n  schema: LoadedSchema,\n  allSchemas: SchemaCollection,\n  options: ResolvedSqlOptions\n): SqlTable {\n  const columns: SqlColumn[] = [];\n  const foreignKeys: SqlForeignKey[] = [];\n  const indexes: SqlIndex[] = [];\n  const dialect = options.dialect;\n\n  // Primary key\n  if (schema.options?.id !== false) {\n    const idType = (schema.options?.idType ?? 'BigInt') as 'Int' | 'BigInt' | 'Uuid' | 'String';\n    columns.push(generatePrimaryKey(idType, dialect));\n  }\n\n  // Process properties\n  if (schema.properties) {\n    for (const [propName, property] of Object.entries(schema.properties)) {\n      // Regular column\n      const column = propertyToColumn(propName, property, dialect, allSchemas);\n      if (column) {\n        columns.push(column);\n\n        // Add index for unique columns (if not already unique constraint)\n        if (column.unique) {\n          indexes.push({\n            name: `idx_${toTableName(schema.name)}_${column.name}_unique`,\n            columns: [column.name],\n            unique: true,\n          });\n        }\n        continue;\n      }\n\n      // Foreign key (ManyToOne, OneToOne)\n      const fkResult = generateForeignKey(propName, property, schema, dialect, allSchemas);\n      if (fkResult) {\n        columns.push(fkResult.column);\n        foreignKeys.push(fkResult.foreignKey);\n\n        // Add index for FK column\n        indexes.push({\n          name: `idx_${toTableName(schema.name)}_${fkResult.column.name}`,\n          columns: [fkResult.column.name],\n          unique: false,\n        });\n        continue;\n      }\n\n      // Polymorphic columns (MorphTo)\n      const morphResult = generatePolymorphicColumns(propName, property, dialect, allSchemas);\n      if (morphResult) {\n        columns.push(...morphResult.columns);\n        indexes.push(morphResult.index);\n        continue;\n      }\n\n      // Coordinates type (generates latitude/longitude columns)\n      if (property.type === 'Coordinates') {\n        const coordColumns = generateCoordinatesColumns(propName, property, dialect);\n        columns.push(...coordColumns);\n      }\n    }\n  }\n\n  // Timestamps\n  if (schema.options?.timestamps !== false) {\n    columns.push(...generateTimestampColumns(dialect));\n  }\n\n  // Soft delete\n  if (schema.options?.softDelete) {\n    columns.push(generateSoftDeleteColumn(dialect));\n  }\n\n  // Custom indexes from schema options\n  if (schema.options?.indexes) {\n    for (const indexDef of schema.options.indexes) {\n      const indexName = indexDef.name ?? `idx_${toTableName(schema.name)}_${indexDef.columns.map(c => toColumnName(c)).join('_')}`;\n      indexes.push({\n        name: indexName,\n        columns: indexDef.columns.map(c => toColumnName(c)),\n        unique: indexDef.unique ?? false,\n        type: indexDef.type,\n      });\n    }\n  }\n\n  // Unique constraints from schema options\n  if (schema.options?.unique) {\n    // Normalize to array of arrays: ['col'] or [['col1', 'col2']]\n    const uniqueConstraints = Array.isArray(schema.options.unique[0])\n      ? (schema.options.unique as readonly (readonly string[])[])\n      : [schema.options.unique as readonly string[]];\n\n    for (const constraint of uniqueConstraints) {\n      const constraintColumns = constraint.map(c => toColumnName(c));\n      indexes.push({\n        name: `idx_${toTableName(schema.name)}_${constraintColumns.join('_')}_unique`,\n        columns: constraintColumns,\n        unique: true,\n      });\n    }\n  }\n\n  return {\n    name: toTableName(schema.name),\n    columns,\n    foreignKeys,\n    indexes,\n    comment: resolveLocalizedString(schema.displayName),\n  };\n}\n\n/**\n * Generates pivot table for ManyToMany relation.\n */\nexport function generatePivotTable(\n  sourceSchema: LoadedSchema,\n  _propertyName: string,\n  property: PropertyDefinition,\n  allSchemas: SchemaCollection,\n  options: ResolvedSqlOptions\n): SqlTable | null {\n  if (property.type !== 'Association') {\n    return null;\n  }\n\n  const assocProp = property as {\n    relation?: string;\n    target?: string;\n    joinTable?: string;\n    onDelete?: string;\n  };\n\n  if (assocProp.relation !== 'ManyToMany' || !assocProp.target) {\n    return null;\n  }\n\n  const targetSchema = allSchemas[assocProp.target];\n  if (!targetSchema) {\n    return null;\n  }\n\n  const dialect = options.dialect;\n  const sourceTable = toTableName(sourceSchema.name);\n  const targetTable = toTableName(assocProp.target);\n\n  // Pivot table name: alphabetically sorted\n  const tables = [sourceTable, targetTable].sort();\n  const pivotName = assocProp.joinTable ?? `${tables[0]}_${tables[1]}`;\n\n  const sourceIdType = (sourceSchema.options?.idType ?? 'BigInt') as 'Int' | 'BigInt' | 'Uuid' | 'String';\n  const targetIdType = (targetSchema.options?.idType ?? 'BigInt') as 'Int' | 'BigInt' | 'Uuid' | 'String';\n\n  const sourceColName = `${toSnakeCase(sourceSchema.name)}_id`;\n  const targetColName = `${toSnakeCase(assocProp.target)}_id`;\n\n  const columns: SqlColumn[] = [\n    {\n      name: sourceColName,\n      type: getForeignKeyType(sourceIdType, dialect),\n      nullable: false,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: dialect === 'mysql' && ['Int', 'BigInt'].includes(sourceIdType),\n    },\n    {\n      name: targetColName,\n      type: getForeignKeyType(targetIdType, dialect),\n      nullable: false,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: dialect === 'mysql' && ['Int', 'BigInt'].includes(targetIdType),\n    },\n  ];\n\n  const foreignKeys: SqlForeignKey[] = [\n    {\n      name: `fk_${pivotName}_${sourceColName}`,\n      columns: [sourceColName],\n      referencesTable: sourceTable,\n      referencesColumns: ['id'],\n      onDelete: assocProp.onDelete ?? 'CASCADE',\n      onUpdate: 'CASCADE',\n    },\n    {\n      name: `fk_${pivotName}_${targetColName}`,\n      columns: [targetColName],\n      referencesTable: targetTable,\n      referencesColumns: ['id'],\n      onDelete: assocProp.onDelete ?? 'CASCADE',\n      onUpdate: 'CASCADE',\n    },\n  ];\n\n  const indexes: SqlIndex[] = [\n    {\n      name: `idx_${pivotName}_unique`,\n      columns: [sourceColName, targetColName],\n      unique: true,\n    },\n    {\n      name: `idx_${pivotName}_${sourceColName}`,\n      columns: [sourceColName],\n      unique: false,\n    },\n    {\n      name: `idx_${pivotName}_${targetColName}`,\n      columns: [targetColName],\n      unique: false,\n    },\n  ];\n\n  return {\n    name: pivotName,\n    columns,\n    foreignKeys,\n    indexes,\n  };\n}\n\n/**\n * Generates polymorphic pivot table for MorphToMany relation.\n */\nexport function generateMorphPivotTable(\n  sourceSchema: LoadedSchema,\n  _propertyName: string,\n  property: PropertyDefinition,\n  allSchemas: SchemaCollection,\n  options: ResolvedSqlOptions\n): SqlTable | null {\n  if (property.type !== 'Association') {\n    return null;\n  }\n\n  const assocProp = property as {\n    relation?: string;\n    target?: string;\n    joinTable?: string;\n    onDelete?: string;\n  };\n\n  if (assocProp.relation !== 'MorphToMany' || !assocProp.target) {\n    return null;\n  }\n\n  const targetSchema = allSchemas[assocProp.target];\n  if (!targetSchema) {\n    return null;\n  }\n\n  const dialect = options.dialect;\n\n  // Pivot table name: taggables, imageables, etc.\n  const morphName = toSnakeCase(assocProp.target).replace(/s$/, '') + 'ables';\n  const pivotName = assocProp.joinTable ?? morphName;\n\n  const targetIdType = (targetSchema.options?.idType ?? 'BigInt') as 'Int' | 'BigInt' | 'Uuid' | 'String';\n  const targetColName = `${toSnakeCase(assocProp.target)}_id`;\n  const morphTypeName = `${morphName.replace(/s$/, '')}_type`;\n  const morphIdName = `${morphName.replace(/s$/, '')}_id`;\n\n  // Find all schemas that have MorphToMany to this target\n  const morphTargets: string[] = [sourceSchema.name];\n  for (const [schemaName, schema] of Object.entries(allSchemas)) {\n    if (schemaName === sourceSchema.name) continue;\n    if (!schema.properties) continue;\n\n    for (const prop of Object.values(schema.properties)) {\n      const p = prop as { type?: string; relation?: string; target?: string };\n      if (p.type === 'Association' && p.relation === 'MorphToMany' && p.target === assocProp.target) {\n        if (!morphTargets.includes(schemaName)) {\n          morphTargets.push(schemaName);\n        }\n      }\n    }\n  }\n\n  // Determine morphable ID type\n  let useUuid = false;\n  for (const targetName of morphTargets) {\n    const schema = allSchemas[targetName];\n    if (schema?.options?.idType === 'Uuid') {\n      useUuid = true;\n      break;\n    }\n  }\n\n  const enumInfo = getEnumType(morphTargets, dialect, `${morphTypeName}_enum`);\n  const morphIdType = useUuid\n    ? (dialect === 'mysql' ? 'CHAR(36)' : dialect === 'postgresql' ? 'UUID' : 'TEXT')\n    : (dialect === 'mysql' ? 'BIGINT UNSIGNED' : dialect === 'postgresql' ? 'BIGINT' : 'INTEGER');\n\n  const columns: SqlColumn[] = [\n    {\n      name: targetColName,\n      type: getForeignKeyType(targetIdType, dialect),\n      nullable: false,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: dialect === 'mysql' && ['Int', 'BigInt'].includes(targetIdType),\n    },\n    {\n      name: morphTypeName,\n      type: enumInfo.type,\n      nullable: false,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: false,\n    },\n    {\n      name: morphIdName,\n      type: morphIdType,\n      nullable: false,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: dialect === 'mysql' && !useUuid,\n    },\n  ];\n\n  const foreignKeys: SqlForeignKey[] = [\n    {\n      name: `fk_${pivotName}_${targetColName}`,\n      columns: [targetColName],\n      referencesTable: toTableName(assocProp.target),\n      referencesColumns: ['id'],\n      onDelete: assocProp.onDelete ?? 'CASCADE',\n      onUpdate: 'CASCADE',\n    },\n  ];\n\n  const indexes: SqlIndex[] = [\n    {\n      name: `idx_${pivotName}_unique`,\n      columns: [targetColName, morphTypeName, morphIdName],\n      unique: true,\n    },\n    {\n      name: `idx_${pivotName}_${targetColName}`,\n      columns: [targetColName],\n      unique: false,\n    },\n    {\n      name: `idx_${pivotName}_morphable`,\n      columns: [morphTypeName, morphIdName],\n      unique: false,\n    },\n  ];\n\n  return {\n    name: pivotName,\n    columns,\n    foreignKeys,\n    indexes,\n  };\n}\n","/**\n * @famgia/omnify-sql - Migration Generator\n *\n * Generates versioned SQL migration files.\n */\n\nimport type { SchemaCollection, LoadedSchema, PropertyDefinition } from '@famgia/omnify-types';\nimport type {\n  SqlMigration,\n  SqlTable,\n  SqlGeneratorOptions,\n  ResolvedSqlOptions,\n  SqlDialect,\n} from '../types.js';\n\n/**\n * Types that have limited or no support in certain dialects.\n */\nconst DIALECT_INCOMPATIBLE_TYPES: Record<string, { dialects: SqlDialect[]; reason: string }> = {\n  Point: {\n    dialects: ['sqlite'],\n    reason: 'SQLite does not support native spatial types. Point will be stored as TEXT (JSON), which is incompatible with MySQL/PostgreSQL spatial functions (ST_Distance, ST_Within, etc.). Use Coordinates type for cross-database compatibility.',\n  },\n};\n\n/**\n * Index types that have limited or no support in certain dialects.\n */\nconst DIALECT_INCOMPATIBLE_INDEX_TYPES: Record<string, { dialects: SqlDialect[]; reason: string; suggestion?: string }> = {\n  gin: {\n    dialects: ['mysql', 'sqlite'],\n    reason: 'GIN (Generalized Inverted Index) is PostgreSQL-specific.',\n    suggestion: 'For fulltext search, use type: \"fulltext\" instead. For JSONB indexing, this only works in PostgreSQL.',\n  },\n  gist: {\n    dialects: ['mysql', 'sqlite'],\n    reason: 'GiST (Generalized Search Tree) is PostgreSQL-specific.',\n    suggestion: 'For spatial data, use type: \"spatial\" which works on both MySQL and PostgreSQL.',\n  },\n  fulltext: {\n    dialects: ['sqlite'],\n    reason: 'SQLite does not support native fulltext indexes. FTS requires virtual tables which are not auto-generated.',\n    suggestion: 'Consider using a regular index or implementing SQLite FTS manually.',\n  },\n  spatial: {\n    dialects: ['sqlite'],\n    reason: 'SQLite does not support spatial indexes.',\n    suggestion: 'Use Coordinates type with regular indexes for cross-database compatibility.',\n  },\n};\n\n/**\n * Validates that schema types and index types are compatible with the target dialect.\n * Throws an error if incompatible types are found.\n */\nfunction validateSchemaCompatibility(\n  schemas: SchemaCollection,\n  dialect: SqlDialect\n): void {\n  const errors: string[] = [];\n\n  for (const [schemaName, schema] of Object.entries(schemas)) {\n    if (schema.kind === 'enum') continue;\n\n    // Check property types\n    if (schema.properties) {\n      for (const [propName, property] of Object.entries(schema.properties)) {\n        const propType = (property as PropertyDefinition).type;\n        const incompatibility = DIALECT_INCOMPATIBLE_TYPES[propType];\n\n        if (incompatibility && incompatibility.dialects.includes(dialect)) {\n          errors.push(\n            `Schema \"${schemaName}\", property \"${propName}\": Type \"${propType}\" is not supported in ${dialect}. ${incompatibility.reason}`\n          );\n        }\n      }\n    }\n\n    // Check index types\n    if (schema.options?.indexes) {\n      for (const indexDef of schema.options.indexes) {\n        if (indexDef.type) {\n          const incompatibility = DIALECT_INCOMPATIBLE_INDEX_TYPES[indexDef.type];\n\n          if (incompatibility && incompatibility.dialects.includes(dialect)) {\n            const indexName = indexDef.name ?? `index on [${indexDef.columns.join(', ')}]`;\n            let message = `Schema \"${schemaName}\", index \"${indexName}\": Index type \"${indexDef.type}\" is not supported in ${dialect}. ${incompatibility.reason}`;\n            if (incompatibility.suggestion) {\n              message += ` ${incompatibility.suggestion}`;\n            }\n            errors.push(message);\n          }\n        }\n      }\n    }\n  }\n\n  if (errors.length > 0) {\n    throw new Error(\n      `SQL Generator: Incompatible types detected for dialect \"${dialect}\":\\n\\n` +\n      errors.map((e, i) => `${i + 1}. ${e}`).join('\\n\\n') +\n      '\\n\\nTo fix: Either change the type/index or use a compatible dialect.'\n    );\n  }\n}\nimport {\n  formatCreateTable,\n  formatDropTable,\n  formatIndexes,\n  formatColumnComments,\n} from '../dialects/formatter.js';\nimport {\n  schemaToTable,\n  generatePivotTable,\n  generateMorphPivotTable,\n  toTableName,\n} from './schema-builder.js';\n\n/**\n * Resolves options with defaults.\n */\nfunction resolveOptions(options?: SqlGeneratorOptions): ResolvedSqlOptions {\n  return {\n    dialect: options?.dialect ?? 'mysql',\n    ifNotExists: options?.ifNotExists ?? true,\n    generateDown: options?.generateDown ?? true,\n    startVersion: options?.startVersion ?? 1,\n    versionPadding: options?.versionPadding ?? 4,\n  };\n}\n\n/**\n * Formats version number with padding.\n */\nfunction formatVersion(version: number, padding: number): string {\n  return String(version).padStart(padding, '0');\n}\n\n/**\n * Generates file name for a migration.\n */\nfunction generateFileName(version: number, name: string, padding: number): string {\n  const versionStr = formatVersion(version, padding);\n  return `${versionStr}_${name}.sql`;\n}\n\n/**\n * Generates SQL content for a CREATE TABLE migration.\n */\nfunction generateCreateTableSql(\n  table: SqlTable,\n  options: ResolvedSqlOptions\n): string {\n  const lines: string[] = [];\n  const dialect = options.dialect;\n\n  // Header comment\n  lines.push(`-- Migration: Create ${table.name} table`);\n  lines.push(`-- Generated by @famgia/omnify-sql`);\n  lines.push('');\n\n  // CREATE TABLE\n  lines.push(formatCreateTable(table, dialect, { ifNotExists: options.ifNotExists }));\n  lines.push('');\n\n  // Indexes (separate statements)\n  const indexStatements = formatIndexes(table, dialect);\n  if (indexStatements.length > 0) {\n    lines.push('-- Indexes');\n    lines.push(...indexStatements);\n    lines.push('');\n  }\n\n  // Column comments (PostgreSQL)\n  const commentStatements = formatColumnComments(table, dialect);\n  if (commentStatements.length > 0) {\n    lines.push('-- Column comments');\n    lines.push(...commentStatements);\n    lines.push('');\n  }\n\n  // Down migration\n  if (options.generateDown) {\n    lines.push('-- Down migration');\n    lines.push(`-- ${formatDropTable(table.name, dialect, { ifExists: true, cascade: true })}`);\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Topologically sorts schemas based on foreign key dependencies.\n */\nfunction topologicalSort(schemas: SchemaCollection): LoadedSchema[] {\n  const sorted: LoadedSchema[] = [];\n  const visited = new Set<string>();\n  const visiting = new Set<string>();\n\n  function visit(schemaName: string) {\n    if (visited.has(schemaName)) return;\n    if (visiting.has(schemaName)) {\n      // Circular dependency - just skip\n      return;\n    }\n\n    visiting.add(schemaName);\n\n    const schema = schemas[schemaName];\n    if (!schema) return;\n\n    // Visit dependencies first\n    if (schema.properties) {\n      for (const property of Object.values(schema.properties)) {\n        if (property.type === 'Association') {\n          const assocProp = property as { relation?: string; target?: string };\n          if (['ManyToOne', 'OneToOne'].includes(assocProp.relation ?? '') && assocProp.target) {\n            visit(assocProp.target);\n          }\n        }\n      }\n    }\n\n    visiting.delete(schemaName);\n    visited.add(schemaName);\n    sorted.push(schema);\n  }\n\n  for (const schemaName of Object.keys(schemas)) {\n    visit(schemaName);\n  }\n\n  return sorted;\n}\n\n/**\n * Generates all SQL migrations for a schema collection.\n */\nexport function generateMigrations(\n  schemas: SchemaCollection,\n  options?: SqlGeneratorOptions\n): SqlMigration[] {\n  const resolved = resolveOptions(options);\n\n  // Validate type compatibility with target dialect\n  validateSchemaCompatibility(schemas, resolved.dialect);\n\n  const migrations: SqlMigration[] = [];\n  let version = resolved.startVersion;\n\n  // Filter object schemas (skip enums)\n  const objectSchemas: Record<string, LoadedSchema> = {};\n  for (const [name, schema] of Object.entries(schemas)) {\n    if (schema.kind !== 'enum') {\n      objectSchemas[name] = schema;\n    }\n  }\n\n  // Sort schemas by dependency order\n  const sortedSchemas = topologicalSort(objectSchemas);\n\n  // Track created pivot tables to avoid duplicates\n  const createdPivots = new Set<string>();\n\n  // Generate CREATE TABLE migrations for each schema\n  for (const schema of sortedSchemas) {\n    const table = schemaToTable(schema, schemas, resolved);\n\n    migrations.push({\n      version,\n      name: `create_${table.name}`,\n      fileName: generateFileName(version, `create_${table.name}`, resolved.versionPadding),\n      content: generateCreateTableSql(table, resolved),\n      tables: [table.name],\n      type: 'create',\n    });\n\n    version++;\n  }\n\n  // Generate pivot tables for ManyToMany relations\n  for (const schema of sortedSchemas) {\n    if (!schema.properties) continue;\n\n    for (const [propName, property] of Object.entries(schema.properties)) {\n      // ManyToMany pivot tables\n      const pivotTable = generatePivotTable(schema, propName, property, schemas, resolved);\n      if (pivotTable && !createdPivots.has(pivotTable.name)) {\n        createdPivots.add(pivotTable.name);\n\n        migrations.push({\n          version,\n          name: `create_${pivotTable.name}`,\n          fileName: generateFileName(version, `create_${pivotTable.name}`, resolved.versionPadding),\n          content: generateCreateTableSql(pivotTable, resolved),\n          tables: [pivotTable.name],\n          type: 'pivot',\n        });\n\n        version++;\n      }\n\n      // MorphToMany pivot tables\n      const morphPivot = generateMorphPivotTable(schema, propName, property, schemas, resolved);\n      if (morphPivot && !createdPivots.has(morphPivot.name)) {\n        createdPivots.add(morphPivot.name);\n\n        migrations.push({\n          version,\n          name: `create_${morphPivot.name}`,\n          fileName: generateFileName(version, `create_${morphPivot.name}`, resolved.versionPadding),\n          content: generateCreateTableSql(morphPivot, resolved),\n          tables: [morphPivot.name],\n          type: 'pivot',\n        });\n\n        version++;\n      }\n    }\n  }\n\n  return migrations;\n}\n\n/**\n * Generates a single migration from a schema.\n */\nexport function generateMigrationFromSchema(\n  schema: LoadedSchema,\n  allSchemas: SchemaCollection,\n  options?: SqlGeneratorOptions & { version?: number }\n): SqlMigration {\n  const resolved = resolveOptions(options);\n  const version = options?.version ?? resolved.startVersion;\n\n  const table = schemaToTable(schema, allSchemas, resolved);\n\n  return {\n    version,\n    name: `create_${table.name}`,\n    fileName: generateFileName(version, `create_${table.name}`, resolved.versionPadding),\n    content: generateCreateTableSql(table, resolved),\n    tables: [table.name],\n    type: 'create',\n  };\n}\n\n/**\n * Generates a DROP TABLE migration.\n */\nexport function generateDropMigration(\n  tableName: string,\n  options?: SqlGeneratorOptions & { version?: number }\n): SqlMigration {\n  const resolved = resolveOptions(options);\n  const version = options?.version ?? resolved.startVersion;\n\n  // If tableName looks like a table name (snake_case or already pluralized), use as-is\n  // Otherwise treat as schema name and convert\n  const isTableName = tableName.includes('_') || tableName.endsWith('s') || tableName.endsWith('es');\n  const snakeTable = isTableName ? tableName : toTableName(tableName);\n  const dropSql = formatDropTable(snakeTable, resolved.dialect, { ifExists: true, cascade: true });\n\n  const lines: string[] = [\n    `-- Migration: Drop ${snakeTable} table`,\n    '-- Generated by @famgia/omnify-sql',\n    '',\n    dropSql,\n  ];\n\n  return {\n    version,\n    name: `drop_${snakeTable}`,\n    fileName: generateFileName(version, `drop_${snakeTable}`, resolved.versionPadding),\n    content: lines.join('\\n'),\n    tables: [snakeTable],\n    type: 'drop',\n  };\n}\n\n/**\n * Gets the file path for a migration.\n */\nexport function getMigrationPath(migration: SqlMigration, basePath: string = 'migrations'): string {\n  return `${basePath}/${migration.fileName}`;\n}\n"]}
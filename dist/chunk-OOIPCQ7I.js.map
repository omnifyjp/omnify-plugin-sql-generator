{"version":3,"sources":["../src/dialects/formatter.ts","../src/dialects/types.ts","../src/migration/schema-builder.ts","../src/migration/generator.ts"],"sourcesContent":["/**\n * @famgia/omnify-sql - SQL Formatter\n *\n * Formats SQL statements for each dialect.\n */\n\nimport type { SqlDialect, SqlColumn, SqlForeignKey, SqlIndex, SqlTable } from '../types.js';\n\n/**\n * Quotes an identifier based on dialect.\n */\nexport function quoteIdentifier(name: string, dialect: SqlDialect): string {\n  switch (dialect) {\n    case 'mysql':\n      return `\\`${name}\\``;\n    case 'postgresql':\n      return `\"${name}\"`;\n    case 'sqlite':\n      return `\"${name}\"`;\n  }\n}\n\n/**\n * Quotes a string value.\n */\nexport function quoteString(value: string): string {\n  return `'${value.replace(/'/g, \"''\")}'`;\n}\n\n/**\n * Formats a column definition.\n */\nexport function formatColumn(column: SqlColumn, dialect: SqlDialect): string {\n  const parts: string[] = [quoteIdentifier(column.name, dialect), column.type];\n\n  // Unsigned (MySQL only, and only if not already in type)\n  if (dialect === 'mysql' && column.unsigned && !column.type.includes('UNSIGNED')) {\n    parts.push('UNSIGNED');\n  }\n\n  // NOT NULL / NULL\n  if (!column.nullable && !column.primaryKey) {\n    parts.push('NOT NULL');\n  } else if (column.nullable) {\n    parts.push('NULL');\n  }\n\n  // Auto increment\n  if (column.autoIncrement) {\n    switch (dialect) {\n      case 'mysql':\n        parts.push('AUTO_INCREMENT');\n        break;\n      case 'sqlite':\n        // SQLite uses AUTOINCREMENT only with INTEGER PRIMARY KEY\n        break;\n      case 'postgresql':\n        // PostgreSQL uses SERIAL/BIGSERIAL types instead\n        break;\n    }\n  }\n\n  // Primary key (inline for single column)\n  if (column.primaryKey) {\n    parts.push('PRIMARY KEY');\n    if (dialect === 'sqlite' && column.autoIncrement) {\n      parts.push('AUTOINCREMENT');\n    }\n  }\n\n  // Unique\n  if (column.unique && !column.primaryKey) {\n    parts.push('UNIQUE');\n  }\n\n  // Default value\n  if (column.defaultValue !== undefined) {\n    parts.push(`DEFAULT ${column.defaultValue}`);\n  }\n\n  // Comment (MySQL only inline)\n  if (column.comment && dialect === 'mysql') {\n    parts.push(`COMMENT ${quoteString(column.comment)}`);\n  }\n\n  return parts.join(' ');\n}\n\n/**\n * Formats a foreign key constraint.\n */\nexport function formatForeignKey(fk: SqlForeignKey, dialect: SqlDialect): string {\n  const localCols = fk.columns.map(c => quoteIdentifier(c, dialect)).join(', ');\n  const refCols = fk.referencesColumns.map(c => quoteIdentifier(c, dialect)).join(', ');\n  const refTable = quoteIdentifier(fk.referencesTable, dialect);\n\n  let sql = `CONSTRAINT ${quoteIdentifier(fk.name, dialect)} `;\n  sql += `FOREIGN KEY (${localCols}) `;\n  sql += `REFERENCES ${refTable} (${refCols})`;\n\n  if (fk.onDelete && fk.onDelete !== 'NO ACTION') {\n    sql += ` ON DELETE ${fk.onDelete}`;\n  }\n\n  if (fk.onUpdate && fk.onUpdate !== 'NO ACTION') {\n    sql += ` ON UPDATE ${fk.onUpdate}`;\n  }\n\n  return sql;\n}\n\n/**\n * Formats an index definition.\n */\nexport function formatIndex(index: SqlIndex, tableName: string, dialect: SqlDialect): string {\n  const cols = index.columns.map(c => quoteIdentifier(c, dialect)).join(', ');\n  const table = quoteIdentifier(tableName, dialect);\n  const name = quoteIdentifier(index.name, dialect);\n\n  // Handle special index types\n  if (index.type === 'fulltext') {\n    switch (dialect) {\n      case 'mysql':\n        return `CREATE FULLTEXT INDEX ${name} ON ${table} (${cols});`;\n      case 'postgresql':\n        // PostgreSQL uses GIN index with to_tsvector\n        const tsvectorCols = index.columns.map(c => `to_tsvector('english', ${quoteIdentifier(c, dialect)})`).join(' || ');\n        return `CREATE INDEX ${name} ON ${table} USING GIN (${tsvectorCols});`;\n      case 'sqlite':\n        // SQLite FTS requires virtual table, just create regular index\n        return `CREATE INDEX ${name} ON ${table} (${cols});`;\n    }\n  }\n\n  if (index.type === 'spatial') {\n    switch (dialect) {\n      case 'mysql':\n        return `CREATE SPATIAL INDEX ${name} ON ${table} (${cols});`;\n      case 'postgresql':\n        return `CREATE INDEX ${name} ON ${table} USING GIST (${cols});`;\n      case 'sqlite':\n        return `CREATE INDEX ${name} ON ${table} (${cols});`;\n    }\n  }\n\n  if (index.type === 'gin' && dialect === 'postgresql') {\n    return `CREATE INDEX ${name} ON ${table} USING GIN (${cols});`;\n  }\n\n  if (index.type === 'gist' && dialect === 'postgresql') {\n    return `CREATE INDEX ${name} ON ${table} USING GIST (${cols});`;\n  }\n\n  if (index.type === 'hash') {\n    switch (dialect) {\n      case 'mysql':\n        return `CREATE INDEX ${name} ON ${table} (${cols}) USING HASH;`;\n      case 'postgresql':\n        return `CREATE INDEX ${name} ON ${table} USING HASH (${cols});`;\n      case 'sqlite':\n        return `CREATE INDEX ${name} ON ${table} (${cols});`;\n    }\n  }\n\n  // Default: btree or regular index\n  const indexType = index.unique ? 'UNIQUE INDEX' : 'INDEX';\n  return `CREATE ${indexType} ${name} ON ${table} (${cols});`;\n}\n\n/**\n * Formats a complete CREATE TABLE statement.\n */\nexport function formatCreateTable(\n  table: SqlTable,\n  dialect: SqlDialect,\n  options?: { ifNotExists?: boolean }\n): string {\n  const tableName = quoteIdentifier(table.name, dialect);\n  const ifNotExists = options?.ifNotExists ? 'IF NOT EXISTS ' : '';\n\n  const lines: string[] = [];\n\n  // Columns\n  for (const column of table.columns) {\n    lines.push(`  ${formatColumn(column, dialect)}`);\n  }\n\n  // Foreign keys (inline in CREATE TABLE)\n  for (const fk of table.foreignKeys) {\n    lines.push(`  ${formatForeignKey(fk, dialect)}`);\n  }\n\n  let sql = `CREATE TABLE ${ifNotExists}${tableName} (\\n`;\n  sql += lines.join(',\\n');\n  sql += '\\n)';\n\n  // MySQL engine and charset\n  if (dialect === 'mysql') {\n    sql += ' ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci';\n  }\n\n  sql += ';';\n\n  // Add table comment for PostgreSQL (separate statement)\n  if (table.comment && dialect === 'postgresql') {\n    sql += `\\n\\nCOMMENT ON TABLE ${tableName} IS ${quoteString(table.comment)};`;\n  }\n\n  return sql;\n}\n\n/**\n * Formats a DROP TABLE statement.\n */\nexport function formatDropTable(\n  tableName: string,\n  dialect: SqlDialect,\n  options?: { ifExists?: boolean; cascade?: boolean }\n): string {\n  const table = quoteIdentifier(tableName, dialect);\n  const ifExists = options?.ifExists ? 'IF EXISTS ' : '';\n  const cascade = options?.cascade && dialect === 'postgresql' ? ' CASCADE' : '';\n\n  return `DROP TABLE ${ifExists}${table}${cascade};`;\n}\n\n/**\n * Formats indexes as separate statements (after CREATE TABLE).\n */\nexport function formatIndexes(table: SqlTable, dialect: SqlDialect): string[] {\n  return table.indexes.map(index => formatIndex(index, table.name, dialect));\n}\n\n/**\n * Formats column comments for PostgreSQL (separate statements).\n */\nexport function formatColumnComments(table: SqlTable, dialect: SqlDialect): string[] {\n  if (dialect !== 'postgresql') {\n    return [];\n  }\n\n  const statements: string[] = [];\n  const tableName = quoteIdentifier(table.name, dialect);\n\n  for (const column of table.columns) {\n    if (column.comment) {\n      const colName = quoteIdentifier(column.name, dialect);\n      statements.push(\n        `COMMENT ON COLUMN ${tableName}.${colName} IS ${quoteString(column.comment)};`\n      );\n    }\n  }\n\n  return statements;\n}\n","/**\n * @famgia/omnify-sql - Dialect Type Mappings\n *\n * Maps Omnify types to SQL types for each dialect.\n */\n\nimport type { SqlDialect } from '../types.js';\n\n/**\n * Type mapping for each dialect.\n */\nexport interface TypeMapping {\n  /** SQL type string */\n  readonly type: string;\n  /** Whether type supports length parameter */\n  readonly hasLength?: boolean;\n  /** Default length if applicable */\n  readonly defaultLength?: number;\n  /** Whether type supports precision/scale */\n  readonly hasPrecision?: boolean;\n}\n\n/**\n * MySQL type mappings.\n */\nconst MYSQL_TYPES: Record<string, TypeMapping> = {\n  String: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  Int: { type: 'INT' },\n  BigInt: { type: 'BIGINT' },\n  Float: { type: 'DOUBLE' },\n  Decimal: { type: 'DECIMAL', hasPrecision: true },\n  Boolean: { type: 'TINYINT(1)' },\n  Text: { type: 'TEXT' },\n  LongText: { type: 'LONGTEXT' },\n  Date: { type: 'DATE' },\n  Time: { type: 'TIME' },\n  Timestamp: { type: 'TIMESTAMP' },\n  Json: { type: 'JSON' },\n  Email: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  Password: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  File: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  MultiFile: { type: 'JSON' },\n  Uuid: { type: 'CHAR(36)' },\n  Select: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  Lookup: { type: 'BIGINT UNSIGNED' },\n  // Spatial types\n  Point: { type: 'POINT' },\n  Coordinates: { type: 'DECIMAL(10, 8)' }, // For latitude column (longitude uses DECIMAL(11, 8))\n};\n\n/**\n * PostgreSQL type mappings.\n */\nconst POSTGRESQL_TYPES: Record<string, TypeMapping> = {\n  String: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  Int: { type: 'INTEGER' },\n  BigInt: { type: 'BIGINT' },\n  Float: { type: 'DOUBLE PRECISION' },\n  Decimal: { type: 'DECIMAL', hasPrecision: true },\n  Boolean: { type: 'BOOLEAN' },\n  Text: { type: 'TEXT' },\n  LongText: { type: 'TEXT' },\n  Date: { type: 'DATE' },\n  Time: { type: 'TIME' },\n  Timestamp: { type: 'TIMESTAMP' },\n  Json: { type: 'JSONB' },\n  Email: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  Password: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  File: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  MultiFile: { type: 'JSONB' },\n  Uuid: { type: 'UUID' },\n  Select: { type: 'VARCHAR', hasLength: true, defaultLength: 255 },\n  Lookup: { type: 'BIGINT' },\n  // Spatial types (requires PostGIS extension)\n  Point: { type: 'geometry(Point, 4326)' },\n  Coordinates: { type: 'DECIMAL(10, 8)' }, // For latitude column\n};\n\n/**\n * SQLite type mappings.\n */\nconst SQLITE_TYPES: Record<string, TypeMapping> = {\n  String: { type: 'TEXT' },\n  Int: { type: 'INTEGER' },\n  BigInt: { type: 'INTEGER' },\n  Float: { type: 'REAL' },\n  Decimal: { type: 'REAL' },\n  Boolean: { type: 'INTEGER' },\n  Text: { type: 'TEXT' },\n  LongText: { type: 'TEXT' },\n  Date: { type: 'TEXT' },\n  Time: { type: 'TEXT' },\n  Timestamp: { type: 'TEXT' },\n  Json: { type: 'TEXT' },\n  Email: { type: 'TEXT' },\n  Password: { type: 'TEXT' },\n  File: { type: 'TEXT' },\n  MultiFile: { type: 'TEXT' },\n  Uuid: { type: 'TEXT' },\n  Select: { type: 'TEXT' },\n  Lookup: { type: 'INTEGER' },\n  // Spatial types (no native support, use TEXT for JSON or REAL for lat/lon)\n  Point: { type: 'TEXT' }, // JSON representation: {\"lat\": 0, \"lon\": 0}\n  Coordinates: { type: 'REAL' }, // For latitude/longitude columns\n};\n\n/**\n * All dialect mappings.\n */\nconst DIALECT_TYPES: Record<SqlDialect, Record<string, TypeMapping>> = {\n  mysql: MYSQL_TYPES,\n  postgresql: POSTGRESQL_TYPES,\n  sqlite: SQLITE_TYPES,\n};\n\n/**\n * Gets the SQL type for an Omnify type in a specific dialect.\n */\nexport function getSqlType(\n  omnifyType: string,\n  dialect: SqlDialect,\n  options?: { length?: number | undefined; precision?: number | undefined; scale?: number | undefined }\n): string {\n  const mapping = DIALECT_TYPES[dialect][omnifyType];\n\n  if (!mapping) {\n    // Default fallback\n    return dialect === 'sqlite' ? 'TEXT' : 'VARCHAR(255)';\n  }\n\n  let type = mapping.type;\n\n  // Add length if applicable\n  if (mapping.hasLength) {\n    const length = options?.length ?? mapping.defaultLength ?? 255;\n    type = `${type}(${length})`;\n  }\n\n  // Add precision/scale if applicable\n  if (mapping.hasPrecision && options?.precision) {\n    const scale = options.scale ?? 2;\n    type = `${type}(${options.precision}, ${scale})`;\n  }\n\n  return type;\n}\n\n/**\n * Gets the primary key type for a specific dialect.\n */\nexport function getPrimaryKeyType(\n  idType: 'Int' | 'BigInt' | 'Uuid' | 'String',\n  dialect: SqlDialect\n): { type: string; autoIncrement: boolean } {\n  switch (dialect) {\n    case 'mysql':\n      switch (idType) {\n        case 'Int':\n          return { type: 'INT UNSIGNED', autoIncrement: true };\n        case 'BigInt':\n          return { type: 'BIGINT UNSIGNED', autoIncrement: true };\n        case 'Uuid':\n          return { type: 'CHAR(36)', autoIncrement: false };\n        case 'String':\n          return { type: 'VARCHAR(255)', autoIncrement: false };\n      }\n      break;\n\n    case 'postgresql':\n      switch (idType) {\n        case 'Int':\n          return { type: 'SERIAL', autoIncrement: false }; // SERIAL handles auto-increment\n        case 'BigInt':\n          return { type: 'BIGSERIAL', autoIncrement: false };\n        case 'Uuid':\n          return { type: 'UUID', autoIncrement: false };\n        case 'String':\n          return { type: 'VARCHAR(255)', autoIncrement: false };\n      }\n      break;\n\n    case 'sqlite':\n      switch (idType) {\n        case 'Int':\n        case 'BigInt':\n          return { type: 'INTEGER', autoIncrement: true };\n        case 'Uuid':\n        case 'String':\n          return { type: 'TEXT', autoIncrement: false };\n      }\n      break;\n  }\n\n  return { type: 'BIGINT', autoIncrement: true };\n}\n\n/**\n * Gets the foreign key column type.\n */\nexport function getForeignKeyType(\n  referencedIdType: 'Int' | 'BigInt' | 'Uuid' | 'String',\n  dialect: SqlDialect\n): string {\n  switch (dialect) {\n    case 'mysql':\n      switch (referencedIdType) {\n        case 'Int':\n          return 'INT UNSIGNED';\n        case 'BigInt':\n          return 'BIGINT UNSIGNED';\n        case 'Uuid':\n          return 'CHAR(36)';\n        case 'String':\n          return 'VARCHAR(255)';\n      }\n      break;\n\n    case 'postgresql':\n      switch (referencedIdType) {\n        case 'Int':\n          return 'INTEGER';\n        case 'BigInt':\n          return 'BIGINT';\n        case 'Uuid':\n          return 'UUID';\n        case 'String':\n          return 'VARCHAR(255)';\n      }\n      break;\n\n    case 'sqlite':\n      switch (referencedIdType) {\n        case 'Int':\n        case 'BigInt':\n          return 'INTEGER';\n        case 'Uuid':\n        case 'String':\n          return 'TEXT';\n      }\n      break;\n  }\n\n  return 'BIGINT';\n}\n\n/**\n * Gets ENUM type for a dialect.\n * Note: PostgreSQL requires CREATE TYPE, MySQL uses ENUM inline, SQLite uses CHECK.\n */\nexport function getEnumType(\n  values: readonly string[],\n  dialect: SqlDialect,\n  enumName?: string\n): { type: string; preStatement?: string } {\n  switch (dialect) {\n    case 'mysql':\n      const enumValues = values.map(v => `'${v}'`).join(', ');\n      return { type: `ENUM(${enumValues})` };\n\n    case 'postgresql':\n      // PostgreSQL needs CREATE TYPE first\n      const typeName = enumName ?? 'enum_type';\n      const pgValues = values.map(v => `'${v}'`).join(', ');\n      return {\n        type: typeName,\n        preStatement: `CREATE TYPE ${typeName} AS ENUM (${pgValues});`,\n      };\n\n    case 'sqlite':\n      // SQLite uses CHECK constraint, return TEXT and add constraint later\n      return { type: 'TEXT' };\n  }\n}\n","/**\n * @famgia/omnify-sql - Schema Builder\n *\n * Converts Omnify schemas to SQL table definitions.\n */\n\nimport type { LoadedSchema, PropertyDefinition, SchemaCollection } from '@famgia/omnify-types';\nimport { resolveLocalizedString } from '@famgia/omnify-types';\nimport type {\n  SqlDialect,\n  SqlTable,\n  SqlColumn,\n  SqlForeignKey,\n  SqlIndex,\n  ResolvedSqlOptions,\n} from '../types.js';\nimport { getSqlType, getPrimaryKeyType, getForeignKeyType, getEnumType } from '../dialects/types.js';\n\n/**\n * Converts camelCase to snake_case.\n */\nexport function toSnakeCase(str: string): string {\n  return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`).replace(/^_/, '');\n}\n\n/**\n * Converts schema name to table name (snake_case + plural).\n */\nexport function toTableName(schemaName: string): string {\n  const snake = toSnakeCase(schemaName);\n\n  // Simple pluralization rules\n  if (snake.endsWith('y') && !['ay', 'ey', 'oy', 'uy'].some(v => snake.endsWith(v))) {\n    return snake.slice(0, -1) + 'ies';\n  }\n  if (snake.endsWith('s') || snake.endsWith('x') || snake.endsWith('ch') || snake.endsWith('sh')) {\n    return snake + 'es';\n  }\n  return snake + 's';\n}\n\n/**\n * Converts property name to column name (snake_case).\n */\nexport function toColumnName(propertyName: string): string {\n  return toSnakeCase(propertyName);\n}\n\n/**\n * Generates primary key column.\n */\nexport function generatePrimaryKey(\n  idType: 'Int' | 'BigInt' | 'Uuid' | 'String',\n  dialect: SqlDialect\n): SqlColumn {\n  const pkInfo = getPrimaryKeyType(idType, dialect);\n\n  return {\n    name: 'id',\n    type: pkInfo.type,\n    nullable: false,\n    primaryKey: true,\n    autoIncrement: pkInfo.autoIncrement,\n    unique: false,\n    unsigned: false,\n  };\n}\n\n/**\n * Generates timestamp columns (created_at, updated_at).\n */\nexport function generateTimestampColumns(dialect: SqlDialect): SqlColumn[] {\n  const timestampType = dialect === 'sqlite' ? 'TEXT' : 'TIMESTAMP';\n\n  return [\n    {\n      name: 'created_at',\n      type: timestampType,\n      nullable: true,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: false,\n    },\n    {\n      name: 'updated_at',\n      type: timestampType,\n      nullable: true,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: false,\n    },\n  ];\n}\n\n/**\n * Generates soft delete column.\n */\nexport function generateSoftDeleteColumn(dialect: SqlDialect): SqlColumn {\n  const timestampType = dialect === 'sqlite' ? 'TEXT' : 'TIMESTAMP';\n\n  return {\n    name: 'deleted_at',\n    type: timestampType,\n    nullable: true,\n    primaryKey: false,\n    autoIncrement: false,\n    unique: false,\n    unsigned: false,\n  };\n}\n\n/**\n * Generates coordinate columns for Coordinates type.\n * Returns two columns: {name}_latitude and {name}_longitude\n */\nexport function generateCoordinatesColumns(\n  name: string,\n  property: PropertyDefinition,\n  dialect: SqlDialect\n): SqlColumn[] {\n  const baseName = toColumnName(name);\n  const nullable = (property as { nullable?: boolean }).nullable ?? false;\n\n  // Latitude: -90 to +90 (needs 10,8 precision)\n  // Longitude: -180 to +180 (needs 11,8 precision)\n  const latType = dialect === 'sqlite' ? 'REAL' : 'DECIMAL(10, 8)';\n  const lonType = dialect === 'sqlite' ? 'REAL' : 'DECIMAL(11, 8)';\n\n  return [\n    {\n      name: `${baseName}_latitude`,\n      type: latType,\n      nullable,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: false,\n      comment: `Latitude for ${name}`,\n    },\n    {\n      name: `${baseName}_longitude`,\n      type: lonType,\n      nullable,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: false,\n      comment: `Longitude for ${name}`,\n    },\n  ];\n}\n\n/**\n * Converts a property to a SQL column.\n * Returns null for association types and Coordinates (handled separately).\n */\nexport function propertyToColumn(\n  name: string,\n  property: PropertyDefinition,\n  dialect: SqlDialect,\n  _allSchemas: SchemaCollection\n): SqlColumn | null {\n  // Skip associations - they're handled separately\n  if (property.type === 'Association') {\n    return null;\n  }\n\n  // Skip Coordinates - handled separately (generates 2 columns)\n  if (property.type === 'Coordinates') {\n    return null;\n  }\n\n  const columnName = toColumnName(name);\n  const baseProp = property as {\n    nullable?: boolean;\n    unique?: boolean;\n    default?: unknown;\n    displayName?: string;\n    length?: number;\n    precision?: number;\n    scale?: number;\n    enum?: string | readonly string[];\n    options?: readonly string[];\n  };\n\n  // Handle Enum type\n  if (property.type === 'Enum') {\n    if (Array.isArray(baseProp.enum)) {\n      const enumInfo = getEnumType(baseProp.enum, dialect, `${columnName}_enum`);\n      return {\n        name: columnName,\n        type: enumInfo.type,\n        nullable: baseProp.nullable ?? false,\n        primaryKey: false,\n        autoIncrement: false,\n        unique: baseProp.unique ?? false,\n        unsigned: false,\n        defaultValue: baseProp.default !== undefined ? `'${baseProp.default}'` : undefined,\n        comment: baseProp.displayName,\n      };\n    }\n  }\n\n  // Handle Select type\n  if (property.type === 'Select' && baseProp.options) {\n    const enumInfo = getEnumType(baseProp.options, dialect, `${columnName}_enum`);\n    return {\n      name: columnName,\n      type: enumInfo.type,\n      nullable: baseProp.nullable ?? false,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: baseProp.unique ?? false,\n      unsigned: false,\n      defaultValue: baseProp.default !== undefined ? `'${baseProp.default}'` : undefined,\n      comment: baseProp.displayName,\n    };\n  }\n\n  // Standard type mapping\n  const sqlType = getSqlType(property.type, dialect, {\n    length: baseProp.length,\n    precision: baseProp.precision,\n    scale: baseProp.scale,\n  });\n\n  // Format default value\n  let defaultValue: string | undefined;\n  if (baseProp.default !== undefined) {\n    if (typeof baseProp.default === 'string') {\n      defaultValue = `'${baseProp.default}'`;\n    } else if (typeof baseProp.default === 'boolean') {\n      defaultValue = dialect === 'postgresql' ? (baseProp.default ? 'TRUE' : 'FALSE') : (baseProp.default ? '1' : '0');\n    } else {\n      defaultValue = String(baseProp.default);\n    }\n  }\n\n  return {\n    name: columnName,\n    type: sqlType,\n    nullable: baseProp.nullable ?? false,\n    primaryKey: false,\n    autoIncrement: false,\n    unique: baseProp.unique ?? false,\n    unsigned: false,\n    defaultValue,\n    comment: baseProp.displayName,\n  };\n}\n\n/**\n * Generates foreign key column and constraint for an association.\n */\nexport function generateForeignKey(\n  name: string,\n  property: PropertyDefinition,\n  schema: LoadedSchema,\n  dialect: SqlDialect,\n  allSchemas: SchemaCollection\n): { column: SqlColumn; foreignKey: SqlForeignKey } | null {\n  if (property.type !== 'Association') {\n    return null;\n  }\n\n  const assocProp = property as {\n    relation?: string;\n    target?: string;\n    targets?: readonly string[];\n    onDelete?: string;\n    onUpdate?: string;\n  };\n\n  // Only handle owning side relations\n  if (!['ManyToOne', 'OneToOne'].includes(assocProp.relation ?? '')) {\n    return null;\n  }\n\n  const targetName = assocProp.target;\n  if (!targetName) {\n    return null;\n  }\n\n  const targetSchema = allSchemas[targetName];\n  const targetIdType = (targetSchema?.options?.idType ?? 'BigInt') as 'Int' | 'BigInt' | 'Uuid' | 'String';\n\n  const columnName = `${toColumnName(name)}_id`;\n  const fkType = getForeignKeyType(targetIdType, dialect);\n  const constraintName = `fk_${toTableName(schema.name)}_${columnName}`;\n\n  const column: SqlColumn = {\n    name: columnName,\n    type: fkType,\n    nullable: (property as { nullable?: boolean }).nullable ?? false,\n    primaryKey: false,\n    autoIncrement: false,\n    unique: false,\n    unsigned: dialect === 'mysql' && ['Int', 'BigInt'].includes(targetIdType),\n  };\n\n  const foreignKey: SqlForeignKey = {\n    name: constraintName,\n    columns: [columnName],\n    referencesTable: toTableName(targetName),\n    referencesColumns: ['id'],\n    onDelete: assocProp.onDelete ?? 'CASCADE',\n    onUpdate: assocProp.onUpdate ?? 'CASCADE',\n  };\n\n  return { column, foreignKey };\n}\n\n/**\n * Generates polymorphic columns for MorphTo relation.\n */\nexport function generatePolymorphicColumns(\n  name: string,\n  property: PropertyDefinition,\n  dialect: SqlDialect,\n  allSchemas: SchemaCollection\n): { columns: SqlColumn[]; index: SqlIndex } | null {\n  if (property.type !== 'Association') {\n    return null;\n  }\n\n  const assocProp = property as {\n    relation?: string;\n    targets?: readonly string[];\n  };\n\n  if (assocProp.relation !== 'MorphTo' || !assocProp.targets?.length) {\n    return null;\n  }\n\n  const baseName = toColumnName(name);\n\n  // Determine ID type (use UUID if any target uses UUID)\n  let useUuid = false;\n  for (const targetName of assocProp.targets) {\n    const targetSchema = allSchemas[targetName];\n    if (targetSchema?.options?.idType === 'Uuid') {\n      useUuid = true;\n      break;\n    }\n  }\n\n  // Type column (ENUM)\n  const enumInfo = getEnumType(assocProp.targets, dialect, `${baseName}_type_enum`);\n  const typeColumn: SqlColumn = {\n    name: `${baseName}_type`,\n    type: enumInfo.type,\n    nullable: true,\n    primaryKey: false,\n    autoIncrement: false,\n    unique: false,\n    unsigned: false,\n  };\n\n  // ID column\n  const idType = useUuid\n    ? (dialect === 'mysql' ? 'CHAR(36)' : dialect === 'postgresql' ? 'UUID' : 'TEXT')\n    : (dialect === 'mysql' ? 'BIGINT UNSIGNED' : dialect === 'postgresql' ? 'BIGINT' : 'INTEGER');\n\n  const idColumn: SqlColumn = {\n    name: `${baseName}_id`,\n    type: idType,\n    nullable: true,\n    primaryKey: false,\n    autoIncrement: false,\n    unique: false,\n    unsigned: dialect === 'mysql' && !useUuid,\n  };\n\n  // Composite index\n  const index: SqlIndex = {\n    name: `idx_${baseName}_type_id`,\n    columns: [`${baseName}_type`, `${baseName}_id`],\n    unique: false,\n  };\n\n  return {\n    columns: [typeColumn, idColumn],\n    index,\n  };\n}\n\n/**\n * Converts a schema to a SQL table definition.\n */\nexport function schemaToTable(\n  schema: LoadedSchema,\n  allSchemas: SchemaCollection,\n  options: ResolvedSqlOptions\n): SqlTable {\n  const columns: SqlColumn[] = [];\n  const foreignKeys: SqlForeignKey[] = [];\n  const indexes: SqlIndex[] = [];\n  const dialect = options.dialect;\n\n  // Primary key\n  if (schema.options?.id !== false) {\n    const idType = (schema.options?.idType ?? 'BigInt') as 'Int' | 'BigInt' | 'Uuid' | 'String';\n    columns.push(generatePrimaryKey(idType, dialect));\n  }\n\n  // Process properties\n  if (schema.properties) {\n    for (const [propName, property] of Object.entries(schema.properties)) {\n      // Regular column\n      const column = propertyToColumn(propName, property, dialect, allSchemas);\n      if (column) {\n        columns.push(column);\n\n        // Add index for unique columns (if not already unique constraint)\n        if (column.unique) {\n          indexes.push({\n            name: `idx_${toTableName(schema.name)}_${column.name}_unique`,\n            columns: [column.name],\n            unique: true,\n          });\n        }\n        continue;\n      }\n\n      // Foreign key (ManyToOne, OneToOne)\n      const fkResult = generateForeignKey(propName, property, schema, dialect, allSchemas);\n      if (fkResult) {\n        columns.push(fkResult.column);\n        foreignKeys.push(fkResult.foreignKey);\n\n        // Add index for FK column\n        indexes.push({\n          name: `idx_${toTableName(schema.name)}_${fkResult.column.name}`,\n          columns: [fkResult.column.name],\n          unique: false,\n        });\n        continue;\n      }\n\n      // Polymorphic columns (MorphTo)\n      const morphResult = generatePolymorphicColumns(propName, property, dialect, allSchemas);\n      if (morphResult) {\n        columns.push(...morphResult.columns);\n        indexes.push(morphResult.index);\n        continue;\n      }\n\n      // Coordinates type (generates latitude/longitude columns)\n      if (property.type === 'Coordinates') {\n        const coordColumns = generateCoordinatesColumns(propName, property, dialect);\n        columns.push(...coordColumns);\n      }\n    }\n  }\n\n  // Timestamps\n  if (schema.options?.timestamps !== false) {\n    columns.push(...generateTimestampColumns(dialect));\n  }\n\n  // Soft delete\n  if (schema.options?.softDelete) {\n    columns.push(generateSoftDeleteColumn(dialect));\n  }\n\n  // Custom indexes from schema options\n  if (schema.options?.indexes) {\n    for (const indexDef of schema.options.indexes) {\n      const indexName = indexDef.name ?? `idx_${toTableName(schema.name)}_${indexDef.columns.map(c => toColumnName(c)).join('_')}`;\n      indexes.push({\n        name: indexName,\n        columns: indexDef.columns.map(c => toColumnName(c)),\n        unique: indexDef.unique ?? false,\n        type: indexDef.type,\n      });\n    }\n  }\n\n  // Unique constraints from schema options\n  if (schema.options?.unique) {\n    // Normalize to array of arrays: ['col'] or [['col1', 'col2']]\n    const uniqueConstraints = Array.isArray(schema.options.unique[0])\n      ? (schema.options.unique as readonly (readonly string[])[])\n      : [schema.options.unique as readonly string[]];\n\n    for (const constraint of uniqueConstraints) {\n      const constraintColumns = constraint.map(c => toColumnName(c));\n      indexes.push({\n        name: `idx_${toTableName(schema.name)}_${constraintColumns.join('_')}_unique`,\n        columns: constraintColumns,\n        unique: true,\n      });\n    }\n  }\n\n  return {\n    name: toTableName(schema.name),\n    columns,\n    foreignKeys,\n    indexes,\n    comment: resolveLocalizedString(schema.displayName),\n  };\n}\n\n/**\n * Generates pivot table for ManyToMany relation.\n */\nexport function generatePivotTable(\n  sourceSchema: LoadedSchema,\n  _propertyName: string,\n  property: PropertyDefinition,\n  allSchemas: SchemaCollection,\n  options: ResolvedSqlOptions\n): SqlTable | null {\n  if (property.type !== 'Association') {\n    return null;\n  }\n\n  const assocProp = property as {\n    relation?: string;\n    target?: string;\n    joinTable?: string;\n    onDelete?: string;\n  };\n\n  if (assocProp.relation !== 'ManyToMany' || !assocProp.target) {\n    return null;\n  }\n\n  const targetSchema = allSchemas[assocProp.target];\n  if (!targetSchema) {\n    return null;\n  }\n\n  const dialect = options.dialect;\n  const sourceTable = toTableName(sourceSchema.name);\n  const targetTable = toTableName(assocProp.target);\n\n  // Pivot table name: alphabetically sorted\n  const tables = [sourceTable, targetTable].sort();\n  const pivotName = assocProp.joinTable ?? `${tables[0]}_${tables[1]}`;\n\n  const sourceIdType = (sourceSchema.options?.idType ?? 'BigInt') as 'Int' | 'BigInt' | 'Uuid' | 'String';\n  const targetIdType = (targetSchema.options?.idType ?? 'BigInt') as 'Int' | 'BigInt' | 'Uuid' | 'String';\n\n  const sourceColName = `${toSnakeCase(sourceSchema.name)}_id`;\n  const targetColName = `${toSnakeCase(assocProp.target)}_id`;\n\n  const columns: SqlColumn[] = [\n    {\n      name: sourceColName,\n      type: getForeignKeyType(sourceIdType, dialect),\n      nullable: false,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: dialect === 'mysql' && ['Int', 'BigInt'].includes(sourceIdType),\n    },\n    {\n      name: targetColName,\n      type: getForeignKeyType(targetIdType, dialect),\n      nullable: false,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: dialect === 'mysql' && ['Int', 'BigInt'].includes(targetIdType),\n    },\n  ];\n\n  const foreignKeys: SqlForeignKey[] = [\n    {\n      name: `fk_${pivotName}_${sourceColName}`,\n      columns: [sourceColName],\n      referencesTable: sourceTable,\n      referencesColumns: ['id'],\n      onDelete: assocProp.onDelete ?? 'CASCADE',\n      onUpdate: 'CASCADE',\n    },\n    {\n      name: `fk_${pivotName}_${targetColName}`,\n      columns: [targetColName],\n      referencesTable: targetTable,\n      referencesColumns: ['id'],\n      onDelete: assocProp.onDelete ?? 'CASCADE',\n      onUpdate: 'CASCADE',\n    },\n  ];\n\n  const indexes: SqlIndex[] = [\n    {\n      name: `idx_${pivotName}_unique`,\n      columns: [sourceColName, targetColName],\n      unique: true,\n    },\n    {\n      name: `idx_${pivotName}_${sourceColName}`,\n      columns: [sourceColName],\n      unique: false,\n    },\n    {\n      name: `idx_${pivotName}_${targetColName}`,\n      columns: [targetColName],\n      unique: false,\n    },\n  ];\n\n  return {\n    name: pivotName,\n    columns,\n    foreignKeys,\n    indexes,\n  };\n}\n\n/**\n * Generates polymorphic pivot table for MorphToMany relation.\n */\nexport function generateMorphPivotTable(\n  sourceSchema: LoadedSchema,\n  _propertyName: string,\n  property: PropertyDefinition,\n  allSchemas: SchemaCollection,\n  options: ResolvedSqlOptions\n): SqlTable | null {\n  if (property.type !== 'Association') {\n    return null;\n  }\n\n  const assocProp = property as {\n    relation?: string;\n    target?: string;\n    joinTable?: string;\n    onDelete?: string;\n  };\n\n  if (assocProp.relation !== 'MorphToMany' || !assocProp.target) {\n    return null;\n  }\n\n  const targetSchema = allSchemas[assocProp.target];\n  if (!targetSchema) {\n    return null;\n  }\n\n  const dialect = options.dialect;\n\n  // Pivot table name: taggables, imageables, etc.\n  const morphName = toSnakeCase(assocProp.target).replace(/s$/, '') + 'ables';\n  const pivotName = assocProp.joinTable ?? morphName;\n\n  const targetIdType = (targetSchema.options?.idType ?? 'BigInt') as 'Int' | 'BigInt' | 'Uuid' | 'String';\n  const targetColName = `${toSnakeCase(assocProp.target)}_id`;\n  const morphTypeName = `${morphName.replace(/s$/, '')}_type`;\n  const morphIdName = `${morphName.replace(/s$/, '')}_id`;\n\n  // Find all schemas that have MorphToMany to this target\n  const morphTargets: string[] = [sourceSchema.name];\n  for (const [schemaName, schema] of Object.entries(allSchemas)) {\n    if (schemaName === sourceSchema.name) continue;\n    if (!schema.properties) continue;\n\n    for (const prop of Object.values(schema.properties)) {\n      const p = prop as { type?: string; relation?: string; target?: string };\n      if (p.type === 'Association' && p.relation === 'MorphToMany' && p.target === assocProp.target) {\n        if (!morphTargets.includes(schemaName)) {\n          morphTargets.push(schemaName);\n        }\n      }\n    }\n  }\n\n  // Determine morphable ID type\n  let useUuid = false;\n  for (const targetName of morphTargets) {\n    const schema = allSchemas[targetName];\n    if (schema?.options?.idType === 'Uuid') {\n      useUuid = true;\n      break;\n    }\n  }\n\n  const enumInfo = getEnumType(morphTargets, dialect, `${morphTypeName}_enum`);\n  const morphIdType = useUuid\n    ? (dialect === 'mysql' ? 'CHAR(36)' : dialect === 'postgresql' ? 'UUID' : 'TEXT')\n    : (dialect === 'mysql' ? 'BIGINT UNSIGNED' : dialect === 'postgresql' ? 'BIGINT' : 'INTEGER');\n\n  const columns: SqlColumn[] = [\n    {\n      name: targetColName,\n      type: getForeignKeyType(targetIdType, dialect),\n      nullable: false,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: dialect === 'mysql' && ['Int', 'BigInt'].includes(targetIdType),\n    },\n    {\n      name: morphTypeName,\n      type: enumInfo.type,\n      nullable: false,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: false,\n    },\n    {\n      name: morphIdName,\n      type: morphIdType,\n      nullable: false,\n      primaryKey: false,\n      autoIncrement: false,\n      unique: false,\n      unsigned: dialect === 'mysql' && !useUuid,\n    },\n  ];\n\n  const foreignKeys: SqlForeignKey[] = [\n    {\n      name: `fk_${pivotName}_${targetColName}`,\n      columns: [targetColName],\n      referencesTable: toTableName(assocProp.target),\n      referencesColumns: ['id'],\n      onDelete: assocProp.onDelete ?? 'CASCADE',\n      onUpdate: 'CASCADE',\n    },\n  ];\n\n  const indexes: SqlIndex[] = [\n    {\n      name: `idx_${pivotName}_unique`,\n      columns: [targetColName, morphTypeName, morphIdName],\n      unique: true,\n    },\n    {\n      name: `idx_${pivotName}_${targetColName}`,\n      columns: [targetColName],\n      unique: false,\n    },\n    {\n      name: `idx_${pivotName}_morphable`,\n      columns: [morphTypeName, morphIdName],\n      unique: false,\n    },\n  ];\n\n  return {\n    name: pivotName,\n    columns,\n    foreignKeys,\n    indexes,\n  };\n}\n","/**\n * @famgia/omnify-sql - Migration Generator\n *\n * Generates versioned SQL migration files.\n */\n\nimport type { SchemaCollection, LoadedSchema, PropertyDefinition } from '@famgia/omnify-types';\nimport type {\n  SqlMigration,\n  SqlTable,\n  SqlGeneratorOptions,\n  ResolvedSqlOptions,\n  SqlDialect,\n} from '../types.js';\n\n/**\n * Types that have limited or no support in certain dialects.\n */\nconst DIALECT_INCOMPATIBLE_TYPES: Record<string, { dialects: SqlDialect[]; reason: string }> = {\n  Point: {\n    dialects: ['sqlite'],\n    reason: 'SQLite does not support native spatial types. Point will be stored as TEXT (JSON), which is incompatible with MySQL/PostgreSQL spatial functions (ST_Distance, ST_Within, etc.). Use Coordinates type for cross-database compatibility.',\n  },\n};\n\n/**\n * Index types that have limited or no support in certain dialects.\n */\nconst DIALECT_INCOMPATIBLE_INDEX_TYPES: Record<string, { dialects: SqlDialect[]; reason: string; suggestion?: string }> = {\n  gin: {\n    dialects: ['mysql', 'sqlite'],\n    reason: 'GIN (Generalized Inverted Index) is PostgreSQL-specific.',\n    suggestion: 'For fulltext search, use type: \"fulltext\" instead. For JSONB indexing, this only works in PostgreSQL.',\n  },\n  gist: {\n    dialects: ['mysql', 'sqlite'],\n    reason: 'GiST (Generalized Search Tree) is PostgreSQL-specific.',\n    suggestion: 'For spatial data, use type: \"spatial\" which works on both MySQL and PostgreSQL.',\n  },\n  fulltext: {\n    dialects: ['sqlite'],\n    reason: 'SQLite does not support native fulltext indexes. FTS requires virtual tables which are not auto-generated.',\n    suggestion: 'Consider using a regular index or implementing SQLite FTS manually.',\n  },\n  spatial: {\n    dialects: ['sqlite'],\n    reason: 'SQLite does not support spatial indexes.',\n    suggestion: 'Use Coordinates type with regular indexes for cross-database compatibility.',\n  },\n};\n\n/**\n * Validates that schema types and index types are compatible with the target dialect.\n * Throws an error if incompatible types are found.\n */\nfunction validateSchemaCompatibility(\n  schemas: SchemaCollection,\n  dialect: SqlDialect\n): void {\n  const errors: string[] = [];\n\n  for (const [schemaName, schema] of Object.entries(schemas)) {\n    if (schema.kind === 'enum') continue;\n\n    // Check property types\n    if (schema.properties) {\n      for (const [propName, property] of Object.entries(schema.properties)) {\n        const propType = (property as PropertyDefinition).type;\n        const incompatibility = DIALECT_INCOMPATIBLE_TYPES[propType];\n\n        if (incompatibility && incompatibility.dialects.includes(dialect)) {\n          errors.push(\n            `Schema \"${schemaName}\", property \"${propName}\": Type \"${propType}\" is not supported in ${dialect}. ${incompatibility.reason}`\n          );\n        }\n      }\n    }\n\n    // Check index types\n    if (schema.options?.indexes) {\n      for (const indexDef of schema.options.indexes) {\n        if (indexDef.type) {\n          const incompatibility = DIALECT_INCOMPATIBLE_INDEX_TYPES[indexDef.type];\n\n          if (incompatibility && incompatibility.dialects.includes(dialect)) {\n            const indexName = indexDef.name ?? `index on [${indexDef.columns.join(', ')}]`;\n            let message = `Schema \"${schemaName}\", index \"${indexName}\": Index type \"${indexDef.type}\" is not supported in ${dialect}. ${incompatibility.reason}`;\n            if (incompatibility.suggestion) {\n              message += ` ${incompatibility.suggestion}`;\n            }\n            errors.push(message);\n          }\n        }\n      }\n    }\n  }\n\n  if (errors.length > 0) {\n    throw new Error(\n      `SQL Generator: Incompatible types detected for dialect \"${dialect}\":\\n\\n` +\n      errors.map((e, i) => `${i + 1}. ${e}`).join('\\n\\n') +\n      '\\n\\nTo fix: Either change the type/index or use a compatible dialect.'\n    );\n  }\n}\nimport {\n  formatCreateTable,\n  formatDropTable,\n  formatIndexes,\n  formatColumnComments,\n} from '../dialects/formatter.js';\nimport {\n  schemaToTable,\n  generatePivotTable,\n  generateMorphPivotTable,\n  toTableName,\n} from './schema-builder.js';\n\n/**\n * Resolves options with defaults.\n */\nfunction resolveOptions(options?: SqlGeneratorOptions): ResolvedSqlOptions {\n  return {\n    dialect: options?.dialect ?? 'mysql',\n    ifNotExists: options?.ifNotExists ?? true,\n    generateDown: options?.generateDown ?? true,\n    startVersion: options?.startVersion ?? 1,\n    versionPadding: options?.versionPadding ?? 4,\n  };\n}\n\n/**\n * Formats version number with padding.\n */\nfunction formatVersion(version: number, padding: number): string {\n  return String(version).padStart(padding, '0');\n}\n\n/**\n * Generates file name for a migration.\n */\nfunction generateFileName(version: number, name: string, padding: number): string {\n  const versionStr = formatVersion(version, padding);\n  return `${versionStr}_${name}.sql`;\n}\n\n/**\n * Generates SQL content for a CREATE TABLE migration.\n */\nfunction generateCreateTableSql(\n  table: SqlTable,\n  options: ResolvedSqlOptions\n): string {\n  const lines: string[] = [];\n  const dialect = options.dialect;\n\n  // Header comment\n  lines.push(`-- Migration: Create ${table.name} table`);\n  lines.push(`-- Generated by @famgia/omnify-sql`);\n  lines.push('');\n\n  // CREATE TABLE\n  lines.push(formatCreateTable(table, dialect, { ifNotExists: options.ifNotExists }));\n  lines.push('');\n\n  // Indexes (separate statements)\n  const indexStatements = formatIndexes(table, dialect);\n  if (indexStatements.length > 0) {\n    lines.push('-- Indexes');\n    lines.push(...indexStatements);\n    lines.push('');\n  }\n\n  // Column comments (PostgreSQL)\n  const commentStatements = formatColumnComments(table, dialect);\n  if (commentStatements.length > 0) {\n    lines.push('-- Column comments');\n    lines.push(...commentStatements);\n    lines.push('');\n  }\n\n  // Down migration\n  if (options.generateDown) {\n    lines.push('-- Down migration');\n    lines.push(`-- ${formatDropTable(table.name, dialect, { ifExists: true, cascade: true })}`);\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Topologically sorts schemas based on foreign key dependencies.\n */\nfunction topologicalSort(schemas: SchemaCollection): LoadedSchema[] {\n  const sorted: LoadedSchema[] = [];\n  const visited = new Set<string>();\n  const visiting = new Set<string>();\n\n  function visit(schemaName: string) {\n    if (visited.has(schemaName)) return;\n    if (visiting.has(schemaName)) {\n      // Circular dependency - just skip\n      return;\n    }\n\n    visiting.add(schemaName);\n\n    const schema = schemas[schemaName];\n    if (!schema) return;\n\n    // Visit dependencies first\n    if (schema.properties) {\n      for (const property of Object.values(schema.properties)) {\n        if (property.type === 'Association') {\n          const assocProp = property as { relation?: string; target?: string };\n          if (['ManyToOne', 'OneToOne'].includes(assocProp.relation ?? '') && assocProp.target) {\n            visit(assocProp.target);\n          }\n        }\n      }\n    }\n\n    visiting.delete(schemaName);\n    visited.add(schemaName);\n    sorted.push(schema);\n  }\n\n  for (const schemaName of Object.keys(schemas)) {\n    visit(schemaName);\n  }\n\n  return sorted;\n}\n\n/**\n * Generates all SQL migrations for a schema collection.\n */\nexport function generateMigrations(\n  schemas: SchemaCollection,\n  options?: SqlGeneratorOptions\n): SqlMigration[] {\n  const resolved = resolveOptions(options);\n\n  // Validate type compatibility with target dialect\n  validateSchemaCompatibility(schemas, resolved.dialect);\n\n  const migrations: SqlMigration[] = [];\n  let version = resolved.startVersion;\n\n  // Filter object schemas (skip enums)\n  const objectSchemas: Record<string, LoadedSchema> = {};\n  for (const [name, schema] of Object.entries(schemas)) {\n    if (schema.kind !== 'enum') {\n      objectSchemas[name] = schema;\n    }\n  }\n\n  // Sort schemas by dependency order\n  const sortedSchemas = topologicalSort(objectSchemas);\n\n  // Track created pivot tables to avoid duplicates\n  const createdPivots = new Set<string>();\n\n  // Generate CREATE TABLE migrations for each schema\n  for (const schema of sortedSchemas) {\n    const table = schemaToTable(schema, schemas, resolved);\n\n    migrations.push({\n      version,\n      name: `create_${table.name}`,\n      fileName: generateFileName(version, `create_${table.name}`, resolved.versionPadding),\n      content: generateCreateTableSql(table, resolved),\n      tables: [table.name],\n      type: 'create',\n    });\n\n    version++;\n  }\n\n  // Generate pivot tables for ManyToMany relations\n  for (const schema of sortedSchemas) {\n    if (!schema.properties) continue;\n\n    for (const [propName, property] of Object.entries(schema.properties)) {\n      // ManyToMany pivot tables\n      const pivotTable = generatePivotTable(schema, propName, property, schemas, resolved);\n      if (pivotTable && !createdPivots.has(pivotTable.name)) {\n        createdPivots.add(pivotTable.name);\n\n        migrations.push({\n          version,\n          name: `create_${pivotTable.name}`,\n          fileName: generateFileName(version, `create_${pivotTable.name}`, resolved.versionPadding),\n          content: generateCreateTableSql(pivotTable, resolved),\n          tables: [pivotTable.name],\n          type: 'pivot',\n        });\n\n        version++;\n      }\n\n      // MorphToMany pivot tables\n      const morphPivot = generateMorphPivotTable(schema, propName, property, schemas, resolved);\n      if (morphPivot && !createdPivots.has(morphPivot.name)) {\n        createdPivots.add(morphPivot.name);\n\n        migrations.push({\n          version,\n          name: `create_${morphPivot.name}`,\n          fileName: generateFileName(version, `create_${morphPivot.name}`, resolved.versionPadding),\n          content: generateCreateTableSql(morphPivot, resolved),\n          tables: [morphPivot.name],\n          type: 'pivot',\n        });\n\n        version++;\n      }\n    }\n  }\n\n  return migrations;\n}\n\n/**\n * Generates a single migration from a schema.\n */\nexport function generateMigrationFromSchema(\n  schema: LoadedSchema,\n  allSchemas: SchemaCollection,\n  options?: SqlGeneratorOptions & { version?: number }\n): SqlMigration {\n  const resolved = resolveOptions(options);\n  const version = options?.version ?? resolved.startVersion;\n\n  const table = schemaToTable(schema, allSchemas, resolved);\n\n  return {\n    version,\n    name: `create_${table.name}`,\n    fileName: generateFileName(version, `create_${table.name}`, resolved.versionPadding),\n    content: generateCreateTableSql(table, resolved),\n    tables: [table.name],\n    type: 'create',\n  };\n}\n\n/**\n * Generates a DROP TABLE migration.\n */\nexport function generateDropMigration(\n  tableName: string,\n  options?: SqlGeneratorOptions & { version?: number }\n): SqlMigration {\n  const resolved = resolveOptions(options);\n  const version = options?.version ?? resolved.startVersion;\n\n  // If tableName looks like a table name (snake_case or already pluralized), use as-is\n  // Otherwise treat as schema name and convert\n  const isTableName = tableName.includes('_') || tableName.endsWith('s') || tableName.endsWith('es');\n  const snakeTable = isTableName ? tableName : toTableName(tableName);\n  const dropSql = formatDropTable(snakeTable, resolved.dialect, { ifExists: true, cascade: true });\n\n  const lines: string[] = [\n    `-- Migration: Drop ${snakeTable} table`,\n    '-- Generated by @famgia/omnify-sql',\n    '',\n    dropSql,\n  ];\n\n  return {\n    version,\n    name: `drop_${snakeTable}`,\n    fileName: generateFileName(version, `drop_${snakeTable}`, resolved.versionPadding),\n    content: lines.join('\\n'),\n    tables: [snakeTable],\n    type: 'drop',\n  };\n}\n\n/**\n * Gets the file path for a migration.\n */\nexport function getMigrationPath(migration: SqlMigration, basePath: string = 'migrations'): string {\n  return `${basePath}/${migration.fileName}`;\n}\n"],"mappings":"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","names":[]}